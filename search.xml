<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何保证MQ消息顺序性</title>
      <link href="/40c2be128276/"/>
      <url>/40c2be128276/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><p><a href="https://www.bilibili.com/video/BV13mW4zzEDs/">怎么保证mq消息顺序性？保证不了</a><br><a href="https://www.cnblogs.com/wzh2010/p/15888528.html">MQ系列12：如何保证消息顺序性</a></p><p>消息的有序性在很多业务场景中占有很重要的位置。<br>比如购物场景，需要按照 创建订单 -&gt; 订单付款 -&gt; 完成订单 顺序执行。<br>又比如出行场景，接单 -&gt; 接送到达目的地 -&gt; 付款 -&gt; 完成订单。<br>这种是严格按照顺序执行的，这样的顺序消费才不会出问题，而且各个订单之间是互相独立和并行执行的。<br>所以，在 MQ 中，如何稳定地保证顺序性消息处理，是一个不可避免的话题。</p><h1 id="消息的顺序性说明"><a href="#消息的顺序性说明" class="headerlink" title="消息的顺序性说明"></a>消息的顺序性说明</h1><p>消息的有序执行，一般不是单个组件的能力。而是整个消息从生产，排队，存储到消费都是有序的，比如上面提到的购物和出行场景。</p><p>这就要求我们在消息队列（无论是 Kafka、RocketMQ 还是 RabbitMQ）中，保证以下前提：</p><ul><li>消息生产的有序性：即生产者组件有序发送消息。</li><li>消息入出队列的有序性：消息需严格按照进入队列的先后顺序入队和出队，遵循 FIFO 原则。</li><li>消息的存储的有序性：与上一点一致，部分场景下为提高可靠性需持久化到磁盘，这时候应该遵循有序存放，才能保证后续有序消费。</li><li>消息消费的有序性：即按照顺序进行消费。又分为全局顺序消息与局部顺序消息，全局是指 Topic 下的所有消息都要保证顺序；局部顺序消息保证每一组消息被顺序消费即可。</li></ul><h2 id="全局有序和局部有序"><a href="#全局有序和局部有序" class="headerlink" title="全局有序和局部有序"></a>全局有序和局部有序</h2><p><strong>全局有序是所有消息按发送顺序消费，局部有序是指定业务维度的消息按顺序消费</strong></p><table><thead><tr><th>类型</th><th>定义</th><th>业务场景</th><th>实现成本</th></tr></thead><tbody><tr><td>全局有序</td><td>所有消息严格遵循 “发送顺序 &#x3D; 消费顺序”</td><td>股票交易行情（需全量按时间排序）</td><td>极高（仅单队列 + 单消费者）</td></tr><tr><td>局部有序</td><td>同一业务标识（如订单 ID、用户 ID）的消息按顺序消费</td><td>电商订单（下单→支付→发货）、外卖订单（下单→接单→配送）</td><td>较低（多队列 + 按业务 ID 路由）</td></tr></tbody></table><p>大多数业务无需追求全局有序，只需保证局部有序（如同一订单、同一用户的消息顺序）。</p><p>举个例子：<br>外卖平台无需保证 “用户 A 的下单消息” 和 “用户 B 的下单消息” 的顺序（保证了也没有什么意义，因为两个订单是否全局有序执行不会有任何影响），但必须保证 “用户 A 的下单 → 接单 → 配送” 三条消息按顺序消费。若 “配送” 消息先被处理，会出现 “订单还没被接单就开始配送” 的逻辑错误。</p><p>如果想让全局都是顺序性消费，那么只能用一个消费者去消费队列（一般来说也是单个生产者），这是会严重影响整体性能的。</p><p>所以接下来的内容主要围绕局部有序这个需求进行。</p><h1 id="消息有序性的核心"><a href="#消息有序性的核心" class="headerlink" title="消息有序性的核心"></a>消息有序性的核心</h1><h2 id="MQ存储消息的有序性"><a href="#MQ存储消息的有序性" class="headerlink" title="MQ存储消息的有序性"></a>MQ存储消息的有序性</h2><p>消息队列（MQ）本身的特性决定了其存储的顺序性能力：</p><ul><li>单队列&#x2F;分区的 FIFO 特性：同一队列&#x2F;分区的消息存储和投递遵循先进先出原则，MQ 会将同一队列的消息按投递顺序持久化到磁盘</li><li>跨队列&#x2F;分区的无序性：不同队列&#x2F;分区间的消息可能存在网络延迟差异，MQ本身不保证跨队列&#x2F;分区的全局顺序</li></ul><p>所以按顺序发送到 MQ 单队列的消息，取出的时候也是有序的，不需要我们额外做些什么。<br>我们只需要保证消息的生产和消费时的顺序性就行了。</p><h2 id="消息生产的有序性"><a href="#消息生产的有序性" class="headerlink" title="消息生产的有序性"></a>消息生产的有序性</h2><p>要保证整个消息队列的有序性执行，首先要保证消息生产的有序性。<br>一个完整的过程如果被分配到了不同的队列&#x2F;分区，这可能是消息乱序的起点。</p><p>举个例子：<br>一次完整的消费过程：创建订单、付款、完成订单<br>如果这三个消息分别在三个不同的队列，那这三个步骤可以说是并行执行的，很可能 “完成订单” 反而先被消费，发生逻辑错误。</p><p>所以我们必须保证一组顺序的消息都存入同一个队列&#x2F;分区中。</p><p>方案如下：<br><strong>自定义路由算法，让需有序的消息进入同一队列</strong></p><ul><li>一个订单的多个子消息的父订单号是一致，我们把这些消息按照订单号取模，投送到对应的 Queue 中就行了，比如 订单号 % 队列数量（ 163105015 % 9）</li><li>发送消息自定义消息标签（消息标签可以用队列编号命名），一组消息使用同一个标签，该组标签对应的消息都投向标签所在的队列。</li></ul><p>我们可以定义多个队列&#x2F;分区，多个队列同时存在，也意味着可以存在多个消费者。这显然比全局有序需要满足的条件 ”只允许单个队列-单个消费者“ 性能将会更好。</p><h2 id="消息消费的有序性"><a href="#消息消费的有序性" class="headerlink" title="消息消费的有序性"></a>消息消费的有序性</h2><p>既然消息生产和消息持久化都可以做到有序性。那么只要保证消费的有序性，就能保证整个消息队列的有序执行。</p><p>方案如下：<br><strong>每个队列只能由一个消费者消费</strong></p><p>每个 MQ 消息队列只能由一个消费者消费的话，这个消费者最终能拿到MQ消息队列中所有的消息，所以拿到的消息在总体上是有序的（FIFO），可避免多消费者拆分队列导致的顺序混乱。</p><p>每个队列只能由一个消费者消费的方案虽能保证顺序，但会导致性能瓶颈 —— 若队列中消息量过大，单个消费者串行处理会造成消息积压。</p><p>单消费者效率低的问题也有可行的解决方案：<br><strong>消费者内部维护多个阻塞队列，把同一业务 ID 消息投递到同一个阻塞队列，每个阻塞队列单线程串行，多个阻塞队列并行处理</strong>。</p><p>注意事项：</p><ol><li>阻塞队列需单线程串行处理，可以绑定阻塞队列和独立线程来实现。通过多个阻塞队列并行的方式达到多线程的效果。（否则这与多个消费者消费同一个 MQ 队列没有什么区别了）</li><li>当然这种方法要注意对 MQ 进行 ACK 的时机，因为要放到阻塞队列里面执行，所以 ACK 机制必须换成手动 ACK。时机是从阻塞队列取出消息并处理成功后。</li><li>RabbitMQ 的 <code>prefetch</code> 机制控制的是未 ACK 消息的最大数量（预取数），只要未 ACK 消息数低于 <code>prefetch</code> 上限，即使有未处理完成的消息，消费者也会拉取新消息补充到额度上限，不会等待所有消息处理完。（比如设置 <code>prefetch=5</code>，目前有 3 条同时 ACK，另两条未 ACK，消费者不会等待另外两条消息任务执行完成才向 MQ 一下子获取 5 条新消息，而是 ACK 之后检查未 ACK 最大数量，小于 <code>prefetch</code> 则立即获取新消息补至预取上限）</li></ol><h1 id="导致乱序的其他因素"><a href="#导致乱序的其他因素" class="headerlink" title="导致乱序的其他因素"></a>导致乱序的其他因素</h1><h2 id="扩容缩容导致乱序"><a href="#扩容缩容导致乱序" class="headerlink" title="扩容缩容导致乱序"></a>扩容缩容导致乱序</h2><p>上述的保证局部有序较高性能的方案，是绝对不能随便对队列进行扩容缩容的。<br>一旦扩容缩容，消息队列数量就变化了，从而导致本该在一个队列的消息被分配到不同的队列。</p><p>举个例子：<br>“下单” 消息已经分配到队列1，在投递 “支付” 消息前，此时发生扩容，可能导致 “支付” 消息被分配到队列2，上述也说了消息如果不在同一个 MQ 消息队列&#x2F;分区，是不能保证顺序性的。</p><p>所以最好是先把队列数量固定。或者把出现乱序的同一业务 ID 的所有消息重新投递到特殊的队列处理（这个队列做好完全的顺序检查，可以重复入队等来保证消息的顺序执行）。或者双写过渡，先同时向新旧队列写入消息，待旧队列消息消费完毕后，再停止向旧队列写入、开启新队列的消费。</p><h2 id="Rebalance导致乱序"><a href="#Rebalance导致乱序" class="headerlink" title="Rebalance导致乱序"></a>Rebalance导致乱序</h2><p>MQ 的 “Rebalance” 机制（如 Kafka 的消费者组重平衡）会在 “消费者数量变化”（如下线、新增消费者）时，重新分配 “消费者 - 队列” 的绑定关系。若原消费某队列的消费者被分配到新队列，历史消息与新消息会被不同消费者处理，引发乱序。</p><h2 id="消息重试导致乱序"><a href="#消息重试导致乱序" class="headerlink" title="消息重试导致乱序"></a>消息重试导致乱序</h2><p>消息重试也会破坏顺序性。当消息处理失败或者被拒绝时，MQ 会将消息重新入队（当做新的消息被放到当前队列末尾），若此时重试消息（第一顺序执行的消息）排在新消息（如第二顺序才执行的消息）之后，会导致需要有序消费的消息乱序。</p><p>因此消息消费失败只能进行本地重试-&gt;死信队列，不能把消息放回到MQ队列重试。</p><p>如果采用消费者内部维护阻塞队列的方案，只允许线程内同步重试，处理消息的单线程在当前消息处理失败后，直接在当前上下文循环重试（如最多3次），重试期间不处理阻塞队列的下一条消息。从而避免消息重新入队阻塞队列，打乱阻塞队列中消息的顺序。</p><h2 id="兜底措施"><a href="#兜底措施" class="headerlink" title="兜底措施"></a>兜底措施</h2><p>最好把 MQ 看作不太可靠的中间件，不要全依靠 MQ 保证有序性和可靠性。</p><p>不依靠 MQ 队列实现有序性，就需要在消费消息的时候进行业务检查，如：</p><ol><li>保证消息消费的幂等性；</li><li>检查上一个顺序消息是否被消费完成，没有被消费完成的话本消息可以选择重新投递到 MQ 队列消息&#x2F;死信队列，也可以先尝试重入消费者内部的阻塞队列。</li><li>开启定时任务检查对应的数据，做好补偿策略等。</li></ol><p>上述方法可以作为兜底，全做好了也可以完全不依靠 MQ 来保证有序性和可靠性。但是这种全面检查肯定是需要时间和资源的，在高并发的情况下不太适用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><strong>自定义路由算法，让需有序的消息进入同一队列</strong></li><li><strong>每个队列只能由一个消费者消费</strong></li><li><strong>消费者内部维护多个阻塞队列，把同一业务 ID 消息投递到同一个阻塞队列，每个阻塞队列单线程串行，多个阻塞队列并行处理</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty的简单使用</title>
      <link href="/b0f908175cdc/"/>
      <url>/b0f908175cdc/</url>
      
        <content type="html"><![CDATA[<p><strong>Netty的主从Reactor多线程模型</strong>：BossGroup处理连接请求，WorkerGroup处理I&#x2F;O操作</p><p>Netty工作一般需要三个线程组：</p><ul><li><strong>BossGroup</strong>：与客户端建立连接；</li><li><strong>WorkerGroup</strong>：处理已连接的 I&#x2F;O 事件（读写、编解码）；</li><li><strong>自定义业务线程池</strong>：执行耗时的业务逻辑（如数据库操作、复杂计算）；</li></ul><p>具体工作流程：</p><ol><li><strong>监听端口</strong>：BossGroup 中的线程会绑定服务端端口（如 8080），持续监听客户端的 TCP 连接请求（三次握手）；</li><li><strong>接收连接</strong>：当客户端完成 TCP 三次握手后，连接会进入内核的 “已完成连接队列”，BossGroup 的线程调用<code>accept()</code>获取该连接，生成代表连接的<code>Channel</code>对象；</li><li><strong>转交连接</strong>：将<code>Channel</code>注册到 WorkerGroup 中某个线程（<code>EventLoop</code>）的<code>Selector</code>上，此后该连接的所有 I&#x2F;O 事件都由这个 Worker 线程负责。</li></ol><h2 id="BossGroup"><a href="#BossGroup" class="headerlink" title="BossGroup"></a>BossGroup</h2><p><code>BossGroup</code> 的工作非常轻量（仅处理连接建立），因此线程数不需要太多。实际开发中通常直接使用<code>new NioEventLoopGroup(1)</code>——1 个线程足够应对大部分场景。</p><h2 id="WorkerGroup"><a href="#WorkerGroup" class="headerlink" title="WorkerGroup"></a>WorkerGroup</h2><p><code>WorkerGroup</code>是 Netty 处理 I&#x2F;O 事件的核心，它的职责是<strong>处理已建立连接的所有网络事件</strong>，包括：</p><ul><li>读取客户端发送的数据；</li><li>对数据进行编解码（如 JSON 转对象、协议解析）；</li><li>将处理后的数据写回客户端。</li></ul><p>Q：为什么说 WorkerGroup 是 “传送带”？<br>A：WorkerGroup 中的每个线程（<code>EventLoop</code>）都绑定一个<code>Selector</code>（多路复用器），负责监听其管理的所有<code>Channel</code>的 I&#x2F;O 事件。由于 I&#x2F;O 操作是非阻塞的（基于 NIO 的<code>select</code>机制），Worker 线程在等待 I&#x2F;O 就绪时不会阻塞，可高效切换到其他就绪的<code>Channel</code>处理事件 —— 这就像传送带，始终在 “搬运” 数据，不浪费时间等待。</p><p>Q：为什么说 WorkerGroup 需要拒绝耗时操作<br>WorkerGroup 的线程是 “I&#x2F;O 专用” 的，<strong>绝对不能在其中执行耗时业务逻辑</strong>（如查询数据库、调用远程接口）。原因很简单：如果 Worker 线程被耗时任务占用，会导致其管理的所有<code>Channel</code>的 I&#x2F;O 事件无法及时处理，最终引发连接超时、吞吐量下降。</p><p>WorkerGroup 的线程数通常设置为<strong>CPU 核心数 × 2</strong>（Netty 的默认值）。</p><h2 id="业务线程池"><a href="#业务线程池" class="headerlink" title="业务线程池"></a>业务线程池</h2><p>当 WorkerGroup 完成数据的读取和编解码后，就需要处理具体的业务逻辑了（如校验数据、操作数据库、调用 RPC 服务）。这些操作往往耗时较长（毫秒级甚至秒级），如果放在 Worker 线程中执行，会阻塞 I&#x2F;O 处理 —— 因此需要一个专门的<strong>业务线程池</strong>来承载这些 “重活”。</p><p>线程数量分配：</p><ul><li>CPU 密集型：以 “CPU 核心数” 为基准；</li><li>I&#x2F;O 密集型：以 “CPU 核心数 ×2” 为基准。</li></ul><h1 id="基于WebSocket的Netty服务器"><a href="#基于WebSocket的Netty服务器" class="headerlink" title="基于WebSocket的Netty服务器"></a>基于WebSocket的Netty服务器</h1><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;netty.websocket.port:8080&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;netty.websocket.path:/ws&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String webSocketPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;netty.websocket.max-frame-size:65536&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxFrameSize;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;netty.websocket.idle-timeout:60&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> idleTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义的业务线程池</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService businessExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup bossGroup;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup workerGroup;</span><br><span class="line">    <span class="keyword">private</span> Channel serverChannel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectProvider&lt;WebSocketFrameHandler&gt; webSocketFrameHandlerProvider;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        bossGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); <span class="comment">// 默认CPU核心数*2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">// 指定服务器通道类型（NIO非阻塞）</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// 服务端TCP参数配置</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>) <span class="comment">// 半连接队列大小</span></span><br><span class="line">                    .option(ChannelOption.SO_REUSEADDR, <span class="literal">true</span>) <span class="comment">// 端口释放后立即重用</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 客户端连接参数配置（child开头的选项用于子通道）</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>) <span class="comment">// 开启TCP心跳</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>) <span class="comment">// 禁用Nagle算法</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 配置通道初始化器（每个新连接都会执行）</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">                            <span class="comment">// 获取通道流水线（责任链模式，处理器按顺序执行）</span></span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// HTTP编解码处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// HTTP消息聚合器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(maxFrameSize));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// WebSocket 协议升级</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">WebSocketServerProtocolHandler</span>(</span><br><span class="line">                                    webSocketPath, <span class="comment">// WebSocket连接路径</span></span><br><span class="line">                                    <span class="literal">null</span>, <span class="comment">// 子协议（不指定）</span></span><br><span class="line">                                    <span class="literal">true</span>, <span class="comment">// 允许扩展</span></span><br><span class="line">                                    maxFrameSize, <span class="comment">// 最大帧大小</span></span><br><span class="line">                                    <span class="literal">false</span>, <span class="comment">// 不允许掩码（服务端接收客户端消息时）</span></span><br><span class="line">                                    <span class="literal">true</span> <span class="comment">// 自动关闭连接</span></span><br><span class="line">                            ));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 空闲检测（仅读空闲）</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(</span><br><span class="line">                                    idleTimeout, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS</span><br><span class="line">                            ));</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 自定义WebSocket消息处理器（注入业务线程池）</span></span><br><span class="line">                            <span class="type">WebSocketFrameHandler</span> <span class="variable">frameHandler</span> <span class="operator">=</span> webSocketFrameHandlerProvider.getObject();</span><br><span class="line">                            frameHandler.setBusinessExecutor(businessExecutor);</span><br><span class="line">                            pipeline.addLast(frameHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 绑定端口并启动服务</span></span><br><span class="line">            serverChannel = bootstrap.bind(port).sync().channel();</span><br><span class="line">            log.info(<span class="string">&quot;Netty WebSocket server started at ws://localhost:&#123;&#125;&#123;&#125;&quot;</span>, port, webSocketPath);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Netty server start interrupted&quot;</span>, e);</span><br><span class="line">            Thread.currentThread().interrupt(); <span class="comment">// 恢复中断状态</span></span><br><span class="line">            stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Failed to start Netty server&quot;</span>, e);</span><br><span class="line">            stop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止Netty服务器（Spring容器销毁时执行）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        log.info(<span class="string">&quot;Shutting down Netty WebSocket server...&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭服务器通道（解绑端口，停止接收新连接）</span></span><br><span class="line">        <span class="keyword">if</span> (serverChannel != <span class="literal">null</span> &amp;&amp; serverChannel.isActive()) &#123;</span><br><span class="line">            serverChannel.close().addListener(future -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;Server channel closed successfully&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Server channel closed failed&quot;</span>, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭Worker线程组（处理完现有任务后关闭）</span></span><br><span class="line">        <span class="keyword">if</span> (workerGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            workerGroup.shutdownGracefully(<span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .addListener(future -&gt; log.info(<span class="string">&quot;Worker group shutdown completed&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭Boss线程组</span></span><br><span class="line">        <span class="keyword">if</span> (bossGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            bossGroup.shutdownGracefully(<span class="number">1</span>, <span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .addListener(future -&gt; log.info(<span class="string">&quot;Boss group shutdown completed&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;Netty WebSocket server stopped&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前服务器绑定的端口（用于监控）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBoundPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (serverChannel != <span class="literal">null</span> &amp;&amp; serverChannel.isActive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((InetSocketAddress) serverChannel.localAddress()).getPort();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;WebSocketFrame&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务线程池</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService businessExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供业务线程池setter方法，供NettyServer注入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBusinessExecutor</span><span class="params">(ExecutorService businessExecutor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.businessExecutor = businessExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他原有逻辑（channelRead0, 事件处理等）</span></span><br><span class="line">    <span class="comment">// 使用this.businessExecutor提交任务即可</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, WebSocketFrame msg)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 异步处理前，增加引用计数（父类释放时不会导致计数为0）</span></span><br><span class="line">    msg.retain(); </span><br><span class="line"></span><br><span class="line">    businessExecutor.submit(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// 2. 业务线程中处理消息，此时msg未被释放</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> TextWebSocketFrame) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> ((TextWebSocketFrame) msg).text();</span><br><span class="line">                <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> processBusiness(text);</span><br><span class="line">                <span class="comment">// 写回响应时，切换到I/O线程（Netty要求：写操作必须在I/O线程执行）</span></span><br><span class="line">                ctx.executor().execute(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ctx.channel().isActive()) &#123;</span><br><span class="line">                        ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(result));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Business process failed&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 业务处理完后，手动释放引用（平衡之前的retain()）</span></span><br><span class="line">            ReferenceCountUtil.release(msg); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无需手动finally释放——父类会自动处理（此时msg引用计数为1，父类释放后变为0）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于TCP的Netty服务器"><a href="#基于TCP的Netty服务器" class="headerlink" title="基于TCP的Netty服务器"></a>基于TCP的Netty服务器</h1><p> 这个是纯TCP的服务器，之前做测试的时候用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup bossGroup;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup workerGroup;</span><br><span class="line">    <span class="keyword">private</span> Channel serverChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8080</span>; <span class="comment">// Netty 监听端口</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        bossGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); <span class="comment">// 主线程组（处理连接请求）</span></span><br><span class="line">        workerGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); <span class="comment">// 工作线程组（处理 I/O 操作）</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel.class) <span class="comment">// 使用 NIO 传输</span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line"></span><br><span class="line">                        ch.pipeline()</span><br><span class="line">                                <span class="comment">//.addLast(new LoggingHandler(LogLevel.INFO)) // 添加网络层日志</span></span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>())</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>())</span><br><span class="line">                                .addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>()) <span class="comment">// 添加自定义处理器（需实现）</span></span><br><span class="line">                        ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>) <span class="comment">// 连接队列大小</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>); <span class="comment">// 保持 TCP 连接</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定端口并启动服务器</span></span><br><span class="line">        serverChannel = bootstrap.bind(port).sync().channel();</span><br><span class="line">        System.out.println(<span class="string">&quot;Netty server started on port: &quot;</span> + port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (serverChannel != <span class="literal">null</span>) &#123;</span><br><span class="line">            serverChannel.close(); <span class="comment">// 关闭 Channel</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (workerGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            workerGroup.shutdownGracefully(); <span class="comment">// 优雅关闭工作线程组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bossGroup != <span class="literal">null</span>) &#123;</span><br><span class="line">            bossGroup.shutdownGracefully(); <span class="comment">// 优雅关闭主线程组</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Netty server stopped&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received: &quot;</span> + msg);</span><br><span class="line">        ctx.writeAndFlush(<span class="string">&quot;Echo: &quot;</span> + msg); <span class="comment">// 回传消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close(); <span class="comment">// 发生异常时关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br>终端使用telnet连上TCP连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ telnet 127.0.0.1 8080</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line">my fork</span><br><span class="line">Echo: my fork</span><br><span class="line">my spoon</span><br><span class="line">Echo: my spoon</span><br></pre></td></tr></table></figure><p>Netty服务端日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Received: my fork</span><br><span class="line">Received: my spoon</span><br></pre></td></tr></table></figure><p>Netty服务端接收到Msg经过解码编码后进行回应，并记录日志。</p>]]></content>
      
      
      <categories>
          
          <category> 技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式IM设计的胡思乱想</title>
      <link href="/d451d62f56e3/"/>
      <url>/d451d62f56e3/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><p><a href="https://cloud.tencent.com/developer/article/1936475">IM消息机制（一）：保证在线实时消息的可靠投递</a><br><a href="https://blog.csdn.net/qq_21561833/article/details/135681086">分布式websocket即时通信(IM)系统保证消息可靠性【第八期】</a><br><a href="https://blog.yueban.site/2021/02/09/Telegram%20%E5%AE%89%E5%85%A8%E6%96%B9%E6%A1%88%E8%A7%A3%E6%9E%90%20-%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%8A%A0%E5%AF%86/#Authorization-Key-auth-key">Telegram 安全方案解析 - 客户端到服务端的加密</a></p><h1 id="分布式WebSocket"><a href="#分布式WebSocket" class="headerlink" title="分布式WebSocket"></a>分布式WebSocket</h1><p>常见方案在我介绍分布式 WebSocket 的文章有说。<br>我偏好选择 Redis 中央路由+消息队列的方式。</p><p>使用 Netty 服务器代替 Tomcat，创建一个WebSocket服务器。</p><h1 id="X3DH加密"><a href="#X3DH加密" class="headerlink" title="X3DH加密"></a>X3DH加密</h1><p>X3DH仅用于单聊的消息，每条消息发送的时候，服务器端记录发送者的公钥（IK,EK），接收者的公钥（IK,SPK,OPK）。</p><h1 id="消息的可靠投递"><a href="#消息的可靠投递" class="headerlink" title="消息的可靠投递"></a>消息的可靠投递</h1><blockquote><p>Q：为什么在有TCP的情况下还需要自己实现聊天消息的ACK机制？<br>A：TCP是“传输可靠”，应用层ACK是“业务可靠”。</p><p>TCP的可靠性确保数据从发送端的TCP层到接收端的TCP层的字节流完整、有序、无重复。<br>但是在IM系统里面光是传输到是没有意义的，TCP确保数据包到达接收端的TCP层，但接收方应用可能崩溃、卡死或处理失败，各种原因没及时保存数据包导致消息再也无法成功展示给用户，永久漏了这条消息。</p></blockquote><h2 id="六报文设计"><a href="#六报文设计" class="headerlink" title="六报文设计"></a>六报文设计</h2><p>IM系统的六报文设计是<strong>消息可靠投递的核心机制</strong>，通过<strong>双重确认</strong>和<strong>超时重传</strong>确保消息不丢失。</p><p>报文分为三种：</p><ol><li>请求报文（request，后简称为为R）</li><li>应答报文（acknowledge，后简称为A）</li><li>通知报文（notify，后简称为N）</li></ol><p><strong>msg:R&#x2F;A&#x2F;N</strong>：确保消息从发送方到接收方的可靠性。<br><strong>ack:R&#x2F;A&#x2F;N</strong>：确保接收方已读消息，并通知发送方。</p><p>流程</p><ol><li><strong>发送请求（msg:R）</strong>- 客户端A发送消息到服务器（IM Server）。</li><li><strong>发送确认（msg:A）</strong>- IM Server确认消息已接收，返回ACK给客户端A。</li><li><strong>消息通知（msg:N）</strong>- IM Server将消息推送给客户端B（若在线）。</li><li><strong>客户端B确认请求（ack:R）</strong>- 客户端B向 IM Server 发送ACK确认请求收到消息。</li><li><strong>服务端确认（ack:A）</strong>- IM Server确认客户端B的ACK。</li><li><strong>发送方通知（ack:N）</strong>- IM Server通知客户端A消息已送达客户端B。</li></ol><p>可以在消息表维护一个status字段，记录目前状态（sent, delivered, read, finished），从而避免显示的ack:N推送。<br>finish字段用于过滤状态为已读的历史消息，减少网络IO以及没有必要的去重</p><p>整个流程大概如下（单聊）：<br><img src="/Pasted%20image%2020251004153517.png"></p><h2 id="超时与重传"><a href="#超时与重传" class="headerlink" title="超时与重传"></a>超时与重传</h2><p>若客户端向服务器发送消息后，没有收到 msg:A，则需要进行一定次数的重传，同时维护重传计数器，如首次超时 1s 重试，第二次 2s，第三次 4s，最大重试 3 次（避免无限重试），超过次数则标记 “发送失败” 并提示用户。</p><p>重传消息可能会导致多条相同消息发送，本来你也许只想发送一次该条消息的。那给消息设置一个唯一 ID 则是一个很好的解决方案。<br>如客户端使用 UUID 作为请求 ID 来跟踪定位这条消息，用于发送方确认是否成功发送以及获取对应的消息 ID，实际的消息 ID 则由服务器端生成（雪花算法 ID）。</p><h1 id="消息同步机制"><a href="#消息同步机制" class="headerlink" title="消息同步机制"></a>消息同步机制</h1><h2 id="读扩散和写扩散"><a href="#读扩散和写扩散" class="headerlink" title="读扩散和写扩散"></a>读扩散和写扩散</h2><p>写扩散（Write Diffusion）</p><ul><li><strong>核心逻辑</strong>：当一条消息发送到群聊时，将消息<strong>复制并存储到每个群成员的个人收件箱</strong>中。</li><li><strong>形象理解</strong>：类似于 “群发邮件”，发件人一次发送，系统自动给每个收件人复制一份存到他们的邮箱。</li><li><strong>读写特点</strong>：<ul><li>写操作成本高（群成员越多，写入次数越多）；</li><li>读操作简单高效（用户只需查询自己的收件箱，无需额外计算）。</li></ul></li></ul><p>读扩散（Read Diffusion）</p><ul><li><strong>核心逻辑</strong>：当一条消息发送到群聊时，<strong>只存储一份到群的公共消息列表</strong>中。用户读取消息时，再从公共列表中拉取自己有权限查看的消息。</li><li><strong>形象理解</strong>：类似于 “论坛帖子”，发帖人只发一次到论坛，用户各自去论坛查看。</li><li><strong>读写特点</strong>：<ul><li>写操作成本低（无论群大小，只写一次）；</li><li>读操作复杂（需要计算用户可见范围、过滤已读消息等）。</li></ul></li></ul><p>写扩散理论上是每人有自己的信箱，可以使用统一的收件箱存储所有用户的扩散消息。发送者发送消息的时候，还需要额外为接收者在 DB 插入一条记录，每个用户根据自己的 ID 获取相应的扩散信息。</p><p>读扩散不需要为接收者额外插入一条记录，只需要记录发送者发出的消息，用户在消息表中使用自己的 ID 进行过滤获取。</p><p>单聊下读写扩散相差不大，差别在大群聊天就能体现出来了。<br>场景：用户A在1000人的群中发一条消息：<br>写扩散：先存 1 条原始消息到 message 表，再向 1000 个群成员的收件箱各写 1 条关联记录（inbox表需写 1000 条）。<br>读扩散：服务器只需将消息存储到消息表（1次写入），但是由于消息表可能积累很多历史消息的记录，所以读取最新消息时可能会读取大量历史消息再进行去重过滤比较耗时，但是这个缺点可以使用游标过滤解决。</p><h2 id="推送机制"><a href="#推送机制" class="headerlink" title="推送机制"></a>推送机制</h2><p>无论群聊还是单人，由于个人偏好我选择读扩散；</p><p>强制主动推送的时机是用户建立 WebSocket 长连接后；</p><h3 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h3><p>双人聊天均使用服务器主动推送消息；群聊根据群聊大小需选择主动推送还是等待用户 pull。</p><p>当群内产生新消息时，服务器不直接通过 WebSocket 推完整消息，而是推一个 “极简信号”，告知客户端 “某个群有新消息，该 Pull 了”。</p><p>可以利用 Redis 做一个群聊未读功能，只存储群聊未读消息计数不存储信息，等用户进入聊天会话的时候再开始分页查询。用户发送消息时，给该群所有用户的未读计数器计数+1；——使用LUA<br>不是给 1000 人大群建 1000 个独立计数器，而是用 “群为 key，用户为 field， 未读消息计数为 value” 的 Hash 结构，1 个群的所有用户计数器存在 1 个 Redis 键里。</p><p>在线触发时机：服务器需维护 “用户 - WebSocket 连接” 映射表，同时维护 “群 - 用户” 在线关系表，群消息成功写入数据库后，筛选出 “在群内且当前 WebSocket 在线” 的用户，仅给这些用户触发信号推送；</p><p>离线后登陆策略：获取用户所有群的未读计数器，避免一登陆就要等待比较长时间的检索以及大量 ACK:R&#x2F;A&#x2F;N 报文导致客户端和服务端出现性能问题。</p><p>考虑群聊未读计数器的持久化。</p><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>被动推送的方法是 pull + 游标，消息表索引是个联合索引，注意左前缀原则避免索引失效。如果偏移值是 msg_id，那么 msg_id 索引需要放到联合索引最后避免索引失效。</p><p>但是使用 msg_id 单个游标可能会在群聊出现漏消息问题，因为不同用户可能在多个节点生成多个雪花 ID，较小的那个因为网络等问题而导致最后才入库，而此时用户已经更新了游标，导致较早生成（ID较小）但是落库较晚的消息被跳过，并且永远无法被感知读取也是有可能的。<br>这种情况可以使用<strong>复合游标</strong>去解决，使用（<strong>宽松时间戳，msg_id</strong>）作为游标更加安全。Pull 时使用<code>created_at &gt; ? OR (created_at = ? AND msg_id &gt; ?)</code> 去查询，时间戳优先，ID兜底。</p><p>仅使用纯时间戳作为游标也有点问题，Pull 是 “即时查询”，同一时间戳有多条消息可能出现楼消息的情况：<br>消息 X：ID&#x3D;101（先落库）；<br>消息 Y：ID&#x3D;102（中间落库）；<br>消息 Z：ID&#x3D;103（因节点压力延迟 0.5 秒落库）<br>此时用户读到Y就返回了，下次查询时使用 <code>created_at &gt; ?</code> 来查询就会漏掉Z。</p><blockquote><p>时间戳建议用MySQL函数生成来保证全局一致性<br>宽松时间戳是指上条消息的时间戳减去n秒（向前多取1秒）</p></blockquote><h3 id="消息分片"><a href="#消息分片" class="headerlink" title="消息分片"></a>消息分片</h3><p>某帖子看到的，也许也可以考虑：<br>超大群的消息可以采用消息分片，服务器端将群消息按 “时间片” 分片存储到缓存（如每5min一个分片，避免大key问题）。<br>群消息落库后，同步写入 Redis 缓存，避免每次拉取都查底层数据库。如果客户端的游标时间戳（最后一条消息的时间）在这个分片之前，那就到数据库去拉去；否则先从 Redis 获取到分片的所有消息，再根据复合游标过滤已接收的消息再发送给用户端。</p>]]></content>
      
      
      <categories>
          
          <category> 技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式下的WebSocket</title>
      <link href="/3d36dd04b30a/"/>
      <url>/3d36dd04b30a/</url>
      
        <content type="html"><![CDATA[<p>参考：<br><a href="https://zhuanlan.zhihu.com/p/258097038">https://zhuanlan.zhihu.com/p/258097038</a><br><a href="https://lawrenceli.me/blog/websocket-cluster#%E7%AE%80%E5%8D%95%E5%B9%BF%E6%92%AD%E5%AE%9E%E7%8E%B0-websocket-%E9%9B%86%E7%BE%A4">https://lawrenceli.me/blog/websocket-cluster#%E7%AE%80%E5%8D%95%E5%B9%BF%E6%92%AD%E5%AE%9E%E7%8E%B0-websocket-%E9%9B%86%E7%BE%A4</a></p><h1 id="单例WebSocket回顾"><a href="#单例WebSocket回顾" class="headerlink" title="单例WebSocket回顾"></a>单例WebSocket回顾</h1><p>示例代码没有使用 <code>Spring Boot</code> 集成，是使用 <code>javax.websocket</code> API 实现的单例 WebSocket 应用。这是一个简单的例子，实际使用上可以添加心跳检测机制、异步广播、清理无效会话等功能；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/chat&quot;)</span> <span class="comment">// WebSocket 服务端点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleWebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ConcurrentHashMap 存储所有连接会话</span></span><br><span class="line">    <span class="comment">// Key: 会话ID (String), Value: WebSocket会话对象 (Session)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Session&gt; sessions = </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当新客户端连接时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(Session session)</span> &#123;</span><br><span class="line">        <span class="comment">// 将新会话添加到Map</span></span><br><span class="line">        sessions.put(session.getId(), session);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;新客户端连接: &quot;</span> + session.getId());</span><br><span class="line">        sendMessage(session, <span class="string">&quot;欢迎加入聊天室! 你的ID: &quot;</span> + session.getId());</span><br><span class="line">        broadcast(<span class="string">&quot;系统消息: 用户 &quot;</span> + session.getId() + <span class="string">&quot; 加入聊天室&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当收到客户端消息时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message, Session sender)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息 [&quot;</span> + sender.getId() + <span class="string">&quot;]: &quot;</span> + message);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 广播消息给所有客户端</span></span><br><span class="line">        broadcast(<span class="string">&quot;用户 &quot;</span> + sender.getId() + <span class="string">&quot;: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端断开连接时调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">(Session session, CloseReason reason)</span> &#123;</span><br><span class="line">        <span class="comment">// 从Map中移除会话</span></span><br><span class="line">        sessions.remove(session.getId());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;客户端断开: &quot;</span> + session.getId() + <span class="string">&quot;, 原因: &quot;</span> + reason.getReasonPhrase());</span><br><span class="line">        broadcast(<span class="string">&quot;系统消息: 用户 &quot;</span> + session.getId() + <span class="string">&quot; 离开聊天室&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable throwable)</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;连接错误: &quot;</span> + session.getId());</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 广播消息给所有客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">broadcast</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有会话并发送消息</span></span><br><span class="line">        sessions.forEach((id, session) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (session.isOpen()) &#123;</span><br><span class="line">                sendMessage(session, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息给单个客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session 目标会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 要发送的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(Session session, String message)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用异步方式发送，避免阻塞</span></span><br><span class="line">            session.getAsyncRemote().sendText(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;发送消息失败: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写的方法：</p><ul><li>onOpen：在客户端与WebSocket服务连接时触发方法执行</li><li>onClose：在客户端与WebSocket连接断开的时候触发执行</li><li>onMessage：在接收到客户端发送的消息时触发执行</li><li>onError：在发生错误时触发执行</li></ul><p>流程：</p><ol><li>客户端与服务端建立 TCP 连接，使用 HTTP 协议升级为 WebSocket 协议连接到服务端的 <code>/chat</code> 端点，触发 <code>onOpen</code> 方法；</li><li>客户端以 WebSocket 数据帧的形式发送消息；</li><li>服务端的 <code>onMessage</code> 方法被触发；</li><li>服务端使用 WebSocket Session 进行数据发送；</li><li>若客户端主动下线，触发 <code>onClose</code>；若通信时网络中断触发 <code>onError</code>；</li></ol><h1 id="单例和分布式WebSocket的区别"><a href="#单例和分布式WebSocket的区别" class="headerlink" title="单例和分布式WebSocket的区别"></a>单例和分布式WebSocket的区别</h1><p>一图流：</p><table><thead><tr><th><strong>对比维度</strong></th><th><strong>单例环境</strong></th><th><strong>分布式环境</strong></th><th><strong>问题根源</strong></th></tr></thead><tbody><tr><td><strong>连接管理</strong></td><td>单节点内存维护所有连接（如 <code>ConcurrentHashMap</code>）</td><td>连接分散在多个节点，无全局视图</td><td>WebSocket 的 Session 基于 TCP 连接，无法跨节点序列化或共享</td></tr><tr><td><strong>消息路由</strong></td><td>直接遍历本地连接推送消息</td><td>需跨节点定位目标连接，否则部分用户收不到消息</td><td>用户连接可能分布在任意节点，发送方节点无法直接访问接收方连接</td></tr><tr><td><strong>负载均衡</strong></td><td>无需考虑连接分布</td><td>新增&#x2F;减少节点时连接分配不均（如轮询算法）</td><td>持久连接无法像 HTTP 请求那样动态重分配到新节点</td></tr><tr><td><strong>会话状态</strong></td><td>Session 绑定到本地内存</td><td>Session 状态需外部存储（如 Redis）</td><td>WebSocket Session 包含 TCP 连接信息，无法在集群间迁移</td></tr></tbody></table><p>分析：<br>WebSocket 是有状态的协议，每个连接是绑定到特定服务器节点的。</p><p>单体应用下只有一台服务器，所有的客户端连接的都是这一台消息服务器，所以当发布消息者发送消息时，所有的客户端其实已经全部与这台服务器建立了连接，直接群发消息就可以了。</p><p>换成分布式系统后，如果客户端连接的服务器发生故障或负载均衡切换，其他节点无法获取该连接的状态。</p><p>如：客服系统单机部署时，用户A与客服B连接同一节点，消息可正常推送；分布式部署后，若用户A连接节点1，客服B连接节点2，则用户A的消息无法到达客服B。</p><p>单机应用下不会出现通信问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    title 单机部署 - 消息正常推送</span><br><span class="line">    participant 用户A as 用户A</span><br><span class="line">    participant 节点 as 节点1</span><br><span class="line">    participant 客服B as 客服B</span><br><span class="line">    </span><br><span class="line">    rect rgba(0, 128, 0, 0.1)</span><br><span class="line">        用户A-&gt;&gt;节点: 连接请求</span><br><span class="line">        节点--&gt;&gt;用户A: 连接成功</span><br><span class="line">        </span><br><span class="line">        客服B-&gt;&gt;节点: 连接请求</span><br><span class="line">        节点--&gt;&gt;客服B: 连接成功</span><br><span class="line">        </span><br><span class="line">        用户A-&gt;&gt;节点: 发送消息给客服B</span><br><span class="line">        节点-&gt;&gt;节点: 查找本地连接&lt;br/&gt;找到客服B会话</span><br><span class="line">        节点-&gt;&gt;客服B: 推送消息</span><br><span class="line">        客服B--&gt;&gt;节点: 接收成功</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p>分布式下出现通信问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    title 分布式部署 - 消息无法送达</span><br><span class="line">    participant 用户A as 用户A</span><br><span class="line">    participant LB as 负载均衡器</span><br><span class="line">    participant 节点1 as 节点1</span><br><span class="line">    participant 节点2 as 节点2</span><br><span class="line">    participant 客服B as 客服B</span><br><span class="line">    </span><br><span class="line">    rect rgba(128, 0, 0, 0.1)</span><br><span class="line">        用户A-&gt;&gt;LB: 连接请求</span><br><span class="line">        LB-&gt;&gt;节点1: 分配用户A</span><br><span class="line">        节点1-&gt;&gt;用户A: 连接成功</span><br><span class="line">        </span><br><span class="line">        客服B-&gt;&gt;LB: 连接请求</span><br><span class="line">        LB-&gt;&gt;节点2: 分配客服B</span><br><span class="line">        节点2-&gt;&gt;客服B: 连接成功</span><br><span class="line">        </span><br><span class="line">        用户A-&gt;&gt;节点1: 发送消息给客服B</span><br><span class="line">        节点1-&gt;&gt;节点1: 查找本地连接&lt;br/&gt;未找到客服B</span><br><span class="line">        节点1--&gt;&gt;用户A: 发送失败/无响应</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><blockquote><p>Q: WebSocket 连接通过 Nginx 通过 Gateway 再到服务器，连接上之后就不会再走 Nginx 和Gateway 的均衡负载选择后端服务器了吗？</p><p>A: 连接建立后，WebSocket 数据仍需经过 Nginx 和 Gateway，因为它们作为代理维持了 TCP 长连接，会持续作为中间代理，转发所有数据帧，但不再重新选择服务器节点（除非连接中断或主动切换）</p></blockquote><h1 id="常见解决方案"><a href="#常见解决方案" class="headerlink" title="常见解决方案"></a>常见解决方案</h1><h2 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h2><p>原理：<br>使用消息队列进行广播。<br>在接收到消息时，不是直接通过 WebSocket 发送消息给对应客户端，而是发布消息到中间件（如 Redis Pub&#x2F;Sub、RabbitMQ），所有节点消费并判断是否需处理本地连接。</p><p>优点：实现简单，扩展性强。</p><p>缺点：网络流量大（消息被所有节点消费），给所有节点带来压力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant 用户A as 用户A</span><br><span class="line">    participant 节点1 as 节点1</span><br><span class="line">    participant MQ as 消息中间件</span><br><span class="line">    participant 节点2 as 节点2</span><br><span class="line">    participant 客服B as 客服B</span><br><span class="line">    </span><br><span class="line">    rect rgba(0, 100, 200, 0.1)</span><br><span class="line">        note over 用户A,节点1: 用户A发送消息</span><br><span class="line">        用户A-&gt;&gt;节点1: 发送消息给客服B</span><br><span class="line">        </span><br><span class="line">        note over 节点1,MQ: 发布消息到中间件</span><br><span class="line">        节点1-&gt;&gt;MQ: 发布消息到队列&#123;&quot;target&quot;: &quot;客服B&quot;, &quot;content&quot;: &quot;...&quot;&#125;</span><br><span class="line">        </span><br><span class="line">        note over MQ: 中间件广播消息</span><br><span class="line">        MQ--&gt;&gt;节点1: 推送消息（所有节点都收到）</span><br><span class="line">        MQ--&gt;&gt;节点2: 推送消息</span><br><span class="line">        </span><br><span class="line">        note over 节点1,节点1: 节点1处理消息</span><br><span class="line">        节点1-&gt;&gt;节点1: 检查本地连接 客服B不在本节点 → 忽略</span><br><span class="line">        </span><br><span class="line">        note over 节点2,客服B: 节点2处理消息</span><br><span class="line">        节点2-&gt;&gt;节点2: 检查本地连接 找到客服B会话</span><br><span class="line">        节点2-&gt;&gt;客服B: 推送消息</span><br><span class="line">        客服B--&gt;&gt;节点2: 接收成功</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><h2 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h2><p>原理：<br>中央路由表+精准投递。</p><p>如：连接时存储（用户ID, 节点ID）映射关系存储到路由表，发送消息时根据对方客户端所在的节点ID作为消息队列 <code>RoutingKey</code>，精确推送到目标节点的专属队列。</p><p>优点：精准投递，网络高效，消息只发送到目标节点。</p><p>缺点：</p><ol><li>路由表依赖，Redis宕机导致系统不可用；</li><li>状态不一致，客户端意外断开重连到新节点而路由表未更新——可以通过缓存过期续期那一套解决；</li><li>节点1宕机后重启，用户2重新连接到了一个节点2，此前若有等待被发到用户2的消息，那么仍是节点1的专属队列，节点1正要给用户2发送消息时发现本地并没有这个 WebSoket Session，需要重新查询路由表投递给消息队列，导致延时增大；若节点1没恢复，消息则永远不会发送到用户2；</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant C as 客户端A</span><br><span class="line">    participant N1 as 节点1</span><br><span class="line">    participant Redis as 路由表（Redis）</span><br><span class="line">    participant MQ as 消息队列</span><br><span class="line">    participant N2 as 节点2</span><br><span class="line">    participant S as 客服B</span><br><span class="line">    </span><br><span class="line">    C-&gt;&gt;N1: 发送消息</span><br><span class="line">    N1-&gt;&gt;Redis: 查询目标节点</span><br><span class="line">    Redis--&gt;&gt;N1: 返回节点2</span><br><span class="line">    N1-&gt;&gt;MQ: 转发到节点2队列</span><br><span class="line">    MQ-&gt;&gt;N2: 投递消息</span><br><span class="line">    N2-&gt;&gt;S: 推送消息</span><br></pre></td></tr></table></figure><h2 id="哈希环"><a href="#哈希环" class="headerlink" title="哈希环"></a>哈希环</h2><p>不借助这些队列&#x2F;订阅机制，通过哈希函数将用户ID映射到 WebSocket 服务器，实现消息的路由和推送。该方案可以有效减少消息广播带来的网络流量，并提高消息传递的效率。<br>需要通过心跳等机制，去维护节点的存活情况，保证路由到的 WebSocket 服务器节点可用。</p>]]></content>
      
      
      <categories>
          
          <category> 技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式系统 </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>父子任务共用线程池导致死锁</title>
      <link href="/322ab9175e3b/"/>
      <url>/322ab9175e3b/</url>
      
        <content type="html"><![CDATA[<p>父子任务共用线程池导致死锁的核心原因是<strong>资源竞争与循环等待</strong>。当父任务在执行过程中提交子任务到同一线程池，并等待子任务完成时，如果线程池的线程资源被父任务完全占用，子任务无法获取线程执行，父任务又因等待子任务结果而无法释放线程，最终形成死锁。</p><p><strong>原因分析</strong>：</p><ol><li><strong>线程池资源竞争</strong><br> 父任务占用了线程池的所有线程，子任务因无可用线程而被放入队列等待。</li><li><strong>父任务等待子任务结果</strong><br> 父任务通过 <code>Future.get()</code> 等方法阻塞等待子任务完成，而子任务无法执行（因线程被父任务占用）。</li><li><strong>循环依赖</strong><br> 子任务需要父任务释放线程才能执行，父任务需要子任务完成才能释放线程，形成死锁。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadlockDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 创建固定大小为2的线程池（关键点：线程池过小）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 提交父任务</span></span><br><span class="line">        executor.submit(() -&gt; parentTask(<span class="string">&quot;Parent-1&quot;</span>));</span><br><span class="line">        executor.submit(() -&gt; parentTask(<span class="string">&quot;Parent-2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parentTask</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; 开始执行&quot;</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 提交子任务，异步</span></span><br><span class="line">        Future&lt;?&gt; childFuture = executor.submit(() -&gt; &#123;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; 的子任务开始执行&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>); <span class="comment">// 模拟工作</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; 的子任务结束&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 父任务阻塞等待子任务完成（致命点）</span></span><br><span class="line">            childFuture.get(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; 结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>过程分析</strong>：</p><p>假设线程池大小为2（如示例所示）：</p><ol><li><strong>初始状态</strong><ul><li><code>Parent-1</code> 占用线程1</li><li><code>Parent-2</code> 占用线程2</li></ul></li><li><strong>父任务提交子任务</strong><ul><li><code>Parent-1</code> 提交 <code>Child-1</code> → 进入任务队列</li><li><code>Parent-2</code> 提交 <code>Child-2</code> → 进入任务队列</li></ul></li><li><strong>父任务等待子任务</strong><ul><li><code>Parent-1</code> 调用 <code>childFuture.get()</code> → <strong>阻塞等待</strong> <code>Child-1</code> 执行</li><li><code>Parent-2</code> 调用 <code>childFuture.get()</code> → <strong>阻塞等待</strong> <code>Child-2</code> 执行</li></ul></li><li><strong>死锁形成</strong><ul><li>线程池中所有线程（线程1、2）都被父任务占用且处于阻塞状态</li><li>子任务（<code>Child-1</code>, <code>Child-2</code>）在队列中等待空闲线程</li><li>但父任务不释放线程 → 子任务永远得不到执行 → 父任务永远等不到结果</li></ul></li></ol><p>这种情况下，只有当工作队列是有界的，且父任务在阻塞前提交多个子任务使工作队列被占满，从而创建新线程才有可能让死锁解开。（有一种父子任务共用线程池不会出现死锁的情况——队列是 SynchronousQueue 这种无存储功能的）</p><p>在这种父子共用线程池的场景，建议有一个兜底的操作——在父任务在等待子任务结果时设置一个超时时间。虽然这个不能完全避免死锁的出现，但是可以避免永久死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    childFuture.get(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">    <span class="comment">// 1. 取消卡住的子任务</span></span><br><span class="line">    childFuture.cancel(<span class="literal">true</span>); </span><br><span class="line">    <span class="comment">// 2. 记录错误/告警</span></span><br><span class="line">    log.error(<span class="string">&quot;子任务执行超时&quot;</span>, e);</span><br><span class="line">    <span class="comment">// 3. 执行备用方案</span></span><br><span class="line">    fallbackStrategy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那怎么<strong>完全避免</strong>这种死锁呢：</p><ol><li>父任务和子任务用独立线程池；</li><li>避免阻塞等待，使用 <code>CompletableFuture</code> 异步回调</li></ol>]]></content>
      
      
      <categories>
          
          <category> 事故收集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPG简单使用</title>
      <link href="/21a4bb4d997e/"/>
      <url>/21a4bb4d997e/</url>
      
        <content type="html"><![CDATA[<p>参考：<br><a href="https://wiki.archlinux.org/title/GnuPG">https://wiki.archlinux.org/title/GnuPG</a></p><p>介绍：GnuPG 是完整实现了 <a href="https://tools.ietf.org/html/rfc4880">RFC4880</a>（即PGP）所定义的 <a href="https://openpgp.org/about/">OpenPGP</a> 标准的自由软件。GnuPG 可以加密和签名你的数据和通讯信息，包含一个通用的密钥管理系统以及用于各种公钥目录的访问模块。GnuPG，简称 GPG，是一个易于与其它程序整合的命令行工具，拥有很多前端程序和函数库。GnuPG 还支持 S&#x2F;MIME 和 Secure Shell (ssh)。</p><h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><h2 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h2><p>使用非对称加解密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg -r ECAMT -e 1.png </span><br></pre></td></tr></table></figure><p>使用对称加解密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg -c 1.png </span><br></pre></td></tr></table></figure><p>查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line">总计 12960</span><br><span class="line">-rw-r--r-- 1 ECAMT ECAMT 6633916 12月 8日 1.png</span><br><span class="line">-rw-r--r-- 1 ECAMT ECAMT 6634809  5月18日 1.png.gpg</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="comment"># 使用非对称加密</span></span><br><span class="line">file 1.png.gpg </span><br><span class="line">1.png.gpg: data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用对称加密</span></span><br><span class="line">file 1.png.gpg </span><br><span class="line">1.png.gpg: PGP symmetric key encrypted data - AES with 256-bit key salted &amp; iterated - SHA256 .</span><br></pre></td></tr></table></figure><p>无论哪种方式加都是使用 <code>-d</code> 解密（使用 <code>&gt;</code> 代替 <code>-o</code> 输出到 <code>2.png</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg -d 1.png.gpg &gt; 2.png</span><br></pre></td></tr></table></figure><hr><p>使用例：加密归档文件</p><p>可以一口气完成归档压缩加密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsdtar -cf - -J &lt;path/direction&gt; | gpg -c &gt; &lt;xx.gpg&gt;</span><br></pre></td></tr></table></figure><blockquote><p>压缩应在加密前：加密后的数据是随机字节，难以被压缩。因此，若需压缩，务必先压缩再加密。</p></blockquote><blockquote><p>仍建议分开归档压缩和加密的步骤，如 <code>xz</code>（LZMA算法）在压缩数据时，其行为会受到输出目标的类型（文件 vs 管道）的影响，使用管道传输传递给gpg时，xz 使用流式压缩模式，每个数据块可能包含额外的头信息和校验值，导致最后的体积略大。</p></blockquote><h2 id="签名校验"><a href="#签名校验" class="headerlink" title="签名校验"></a>签名校验</h2><p>签名主要用于验证数据的完整性、来源真实性以及防止数据被篡改。</p><p>常用签名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output &lt;doc.sig&gt; --sign &lt;doc&gt;</span><br></pre></td></tr></table></figure><p>校验：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --verify &lt;doc.sig&gt;</span><br></pre></td></tr></table></figure><hr><p>使用例：git提交并签名</p><p>提交时签名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -S --gpg-sign=ECAMT</span><br></pre></td></tr></table></figure><p>查看（需要提前导入公钥）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --show-signature</span><br></pre></td></tr></table></figure><p>git设置为指定自动私钥签名（仍需要 <code>-S</code> 参数）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config <span class="built_in">set</span> user.signingKey &lt;user-id&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 校验</span></span><br><span class="line">git config get user.signingKey &lt;user-id&gt;</span><br></pre></td></tr></table></figure><p>git设置每次自动签名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config commit.gpgsign <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>电子邮件完整验证也能用到。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h1 id="主目录"><a href="#主目录" class="headerlink" title="主目录"></a>主目录</h1><p>GnuPG 套件将密钥环和私钥存储在 GnuPG 主目录，并从中读取配置。默认路径为 <code>~/.gnupg</code>。有两种方法可以改变主目录的路径：</p><ul><li>设置 <code>$GNUPGHOME</code> <a href="https://wiki.archlinuxcn.org/wiki/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" title="环境变量">环境变量</a>。</li><li>使用 <code>--homedir</code> 参数，如 <code>$ gpg --homedir &lt;/path/to/dir&gt;</code></li></ul><p>默认情况下，<strong>主目录的<a href="https://wiki.archlinuxcn.org/wiki/Permissions" title="Permissions">权限</a>设置为 <code>700</code>，其包含的文件的权限设置为 <code>600</code></strong>。只有目录的所有者有权读取、写入和访问文件。这是出于安全目的，不应更改。如果此目录或其中的任何文件不遵循此安全措施，您将收到有关不安全文件和主目录权限的警告。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>GnuPG 的所有行为都可以通过命令行参数进行配置。对于您希望成为默认参数的参数，可以将它们添加到相应的配置文件中：</p><ul><li>gpg 检查 <code>gnupg_home/gpg.conf</code>（用户）和 <code>/etc/gnupg/gpg.conf</code>（全局）。由于 gpg 是 GnuPG 的主要入口点，因此大部分感兴趣的配置都在这里。请参阅 <a href="https://www.gnupg.org/documentation/manuals/gnupg/GPG-Options.html">GPG 选项</a> 获取可能的选项。</li><li>dirmngr 会检查 <code>gnupg_home/dirmngr.conf</code> 和 <code>/etc/gnupg/dirmngr.conf</code> 两个配置文件。dirmngr 是由 gpg 内部调用的程序，用于访问 PGP 密钥服务器。请参阅 <a href="https://www.gnupg.org/documentation/manuals/gnupg/Dirmngr-Options.html">Dirmngr 选项</a> 以了解可能的选项。</li></ul><p>这两个配置文件涵盖了常见用例，但 GnuPG  套件中还有更多带有自己选项的辅助程序。请参阅 <a href="https://www.gnupg.org/documentation/manuals/gnupg/index.html">GnuPG 手册</a> 获取详细列表。</p><p>创建所需的文件，并按照 主目录 章节中讨论的方法设置其权限为600。</p><p>在这些文件中添加任何你想要的长选项。不要写两个破折号，只需写选项的名称和所需的参数。例如，要始终使GnuPG在特定路径上使用密钥环，就像使用 <code>gpg --no-default-keyring --keyring keyring-path ...</code> 调用它一样： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gnupg_home/gpg.conf (或 /etc/gnupg/gpg.conf)</span><br><span class="line">---</span><br><span class="line">no-default-keyring</span><br><span class="line">keyring &lt;keyring-path&gt;</span><br></pre></td></tr></table></figure><h2 id="新用户的默认选项"><a href="#新用户的默认选项" class="headerlink" title="新用户的默认选项"></a>新用户的默认选项</h2><p>要给新建用户设定一些默认选项，把配置文件放到 <code>/etc/skel/.gnupg/</code>。系统创建新用户时，就会把文件复制到 GnuPG 目录。还有一个 <em>addgnupghome</em> 命令可以为已有用户创建新 GnuPG 主目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addgnupghome user1 user2</span><br></pre></td></tr></table></figure><p>此命令会检查 <code>/home/user1/.gnupg/</code> 和 <code>/home/user2/.gnupg/</code>，并从 skeleton 目录复制文件过去。具有已存在的 GnuPG 主目录的用户只需跳过即可。</p><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><blockquote><p>注意：</p><ul><li>如果需要一个 <em><code>user-id</code></em>，可以使用 key ID、指纹、用户名或电邮地址的部分等替代，GnuPG 对此的处理很灵活。</li><li>如果需要一个 <em><code>key-id</code></em>，可以给命令加上 <code>--keyid-format=long</code> 选项来查询。例如，如果想要查看主密匙，可以使用<code>gpg --list-secret-keys --keyid-format=long user-id</code>命令，<em>key-id</em> 是和 <em>sec</em> 同一行的十六进制散列值。</li></ul></blockquote><h2 id="创建密钥对"><a href="#创建密钥对" class="headerlink" title="创建密钥对"></a>创建密钥对</h2><p>用下面命令创建一个密钥对：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --full-gen-key</span><br></pre></td></tr></table></figure><p>使用 <code>--expert</code> 选项可以选择其它的加密算法，尤其是较新的<a href="https://zh.wikipedia.org/wiki/%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF%E5%AF%86%E7%A0%81%E5%AD%A6" title="zhwp:椭圆曲线密码学">ECC（椭圆曲线加密）</a>。</p><p>命令执行后会需要用户回答一些问题，大部分用户应该需要的是：</p><ul><li>默认的“RSA 和 RSA”用于加密和解密。</li><li>默认的密钥长度，即 3072。增大长度到 4096“成本极高，但获益很少”。<a href="https://www.gnupg.org/faq/gnupg-faq.html#no_default_of_rsa4096">这个帖子说明了为何 GPG 不默认使用 RSA-4096</a>。</li><li>过期日期。大部分用户可以选择一年。这样即使无法访问密钥环，用户也知道密钥已经过期。如果有需要，可以不重新签发密钥就延长过期时间。</li><li>用户名和电子邮件。可以给同样的密钥不同的身份，比如给同一个密钥关联多个电子邮件。</li><li><strong>不填写</strong>可选注释。注释字段并没有被<a href="https://lists.gnupg.org/pipermail/gnupg-devel/2015-July/030150.html">很好地定义</a>，作用有限。</li><li>一个安全的密钥口令。可参考<a href="https://wiki.archlinuxcn.org/wiki/Security#%E9%80%89%E6%8B%A9%E5%AE%89%E5%85%A8%E7%9A%84%E5%AF%86%E7%A0%81" title="Security">如何选择安全的密码</a>。</li></ul><blockquote><p>注意：任何导入密钥的人都可以看到这里的用户名和电子邮件地址。</p></blockquote><blockquote><p>提示：较简单的 <code>--gen-key</code> 选项对密钥类型、密钥长度、过期时间均使用默认值，仅询问姓名和电邮地址。</p></blockquote><h2 id="查看密钥"><a href="#查看密钥" class="headerlink" title="查看密钥"></a>查看密钥</h2><p>查看公钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --list-keys</span><br></pre></td></tr></table></figure><p>查看私钥:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --list-secret-keys</span><br></pre></td></tr></table></figure><h2 id="导出公钥"><a href="#导出公钥" class="headerlink" title="导出公钥"></a>导出公钥</h2><p>GPG 的主要用途是通过公钥加密信息以确保其私密性。你可以分发自己的公钥，而其他人通过该公钥加密发给你的信息。而你的私钥必须<strong>始终</strong>保密，否则将会威胁信息的私密性。相关内容，请参见<a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86" title="zhwp:公开密钥加密">公开密钥加密</a>。</p><p>所以其他人需要有你的公钥才能给你发加密信息。</p><p>以下命令可生成公钥的 ASCII 版本（<code>--armor</code> 参数）（例如用于以电子邮件发布）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --<span class="built_in">export</span> --armor --output &lt;public-key.asc&gt; &lt;user-id&gt;</span><br></pre></td></tr></table></figure><p>此外，还可以通过<a href="https://wiki.archlinuxcn.org/wiki/GnuPG#%E4%BD%BF%E7%94%A8%E5%85%AC%E9%92%A5%E6%9C%8D%E5%8A%A1%E5%99%A8">密钥服务器</a>分发公钥。</p><blockquote><p>提示：</p><ul><li>使用 <code>--no-emit-version</code> 可以避免打印版本号，通过配置文件也可以进行此设置。</li><li>可以省略 <code>user-id</code> 以导出密钥环内所有的公钥。这可以用来分享多个身份，或是将其导入到另一个程序，比如 <a href="https://wiki.archlinuxcn.org/wiki/Thunderbird#Use_OpenPGP_with_external_GnuPG" title="Thunderbird">Thunderbird</a>。</li></ul></blockquote><h2 id="导入公共密钥"><a href="#导入公共密钥" class="headerlink" title="导入公共密钥"></a>导入公共密钥</h2><p>要给其他人发送加密信息，或者验证他们的签名，就需要他们的公钥。通过文件 <code>public.key</code> 导入公钥到密钥环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --import &lt;public.key.asc&gt;</span><br></pre></td></tr></table></figure><p>此外，还可以通过<a href="https://wiki.archlinuxcn.org/wiki/GnuPG#%E5%AF%86%E9%92%A5%E6%9C%8D%E5%8A%A1%E5%99%A8">#密钥服务器</a>导入公钥。</p><h2 id="使用公钥服务器"><a href="#使用公钥服务器" class="headerlink" title="使用公钥服务器"></a>使用公钥服务器</h2><h3 id="发布公钥"><a href="#发布公钥" class="headerlink" title="发布公钥"></a>发布公钥</h3><p>你可以将你的公钥注册到一个公共的密钥服务器，这样其他人不用联系你就能获取到你的公钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --send-keys &lt;key-id&gt;</span><br></pre></td></tr></table></figure><blockquote><p>警告：一旦一个公钥被发送到密钥服务器，它就无法从服务器上删除。<a href="https://pgp.mit.edu/faq.html">这个网页</a>解释了原因。</p></blockquote><blockquote><p>注意：与公钥相关联的电邮地址一旦公开，可能会被垃圾邮件发送者盯上。请做好相应的防护措施。</p></blockquote><h3 id="搜索和接收公钥"><a href="#搜索和接收公钥" class="headerlink" title="搜索和接收公钥"></a>搜索和接收公钥</h3><p>要查询公钥的详细信息而不是导入，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --search-keys &lt;user-id&gt;</span><br></pre></td></tr></table></figure><p>要导入一个公钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --receive-keys &lt;key-id&gt;</span><br></pre></td></tr></table></figure><p>要使用密钥服务器中的最新版本刷新&#x2F;更新钥匙串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --refresh-keys</span><br></pre></td></tr></table></figure><blockquote><p>警告：</p><ul><li>您应该通过将其指纹与所有者在独立来源（例如直接联系该人）上发布的指纹进行比较，以验证检索到的公钥的真实性。请参阅 <a href="https://en.wikipedia.org/wiki/Public_key_fingerprint" title="wikipedia:Public key fingerprint">Wikipedia:Public key fingerprint</a> 获取更多信息。</li><li>接收密钥时，建议使用长密钥 ID 或完整指纹。使用短密钥 ID 可能会导致冲突。所有具有短密钥 ID 的密钥都将被导入，参见 <a href="https://lore.kernel.org/lkml/20160815153401.9EC2BADC2C@smtp.postman.i2p/">在野外发现的伪密钥</a>作为示例。</li></ul></blockquote><blockquote><p>提示：将 <code>auto-key-retrieve</code> 添加到 <a href="https://wiki.archlinuxcn.org/wiki/GnuPG#Configuration_files">GPG 配置文件</a>中，将在需要时自动从密钥服务器获取密钥。这不会对安全性造成妥协，但可以被视为<strong>侵犯隐私</strong>；请参阅<a href="https://man.archlinux.org/man/gpg.1">gpg(1)</a>中的”web bug”。</p></blockquote><h3 id="公钥服务器"><a href="#公钥服务器" class="headerlink" title="公钥服务器"></a>公钥服务器</h3><p>常见的公钥服务器：</p><ul><li><a href="https://keyserver.ubuntu.com/">Ubuntu Keyserver</a>：联盟式（federated）、没有验证、公钥不可删除。</li><li><a href="https://keys.mailvelope.com/">Mailvelope Keyserver</a>：中心式、验证电邮 ID、公钥可删除。</li><li><a href="https://keys.openpgp.org/">keys.openpgp.org</a>：中心式、验证电邮 ID、公钥可删除、没有第三方签名（即不支持信任网络）。</li></ul><p><a href="https://en.wikipedia.org/wiki/Key_server_(cryptographic)#Keyserver_examples" title="wikipedia:Key server (cryptographic)">维基百科（英文）</a>上有更多的服务器。</p><p>备选公钥服务器可以在 配置文件 中的 <code>keyserver</code> 选项中注明，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.gnupg/dirmngr.conf</span><br><span class="line">---</span><br><span class="line">keyserver hkp://keyserver.ubuntu.com</span><br></pre></td></tr></table></figure><p>当常规服务器无法正常工作时，临时使用另一台服务器很方便。例如，可以通过以下方法实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --keyserver &lt;hkps://keys.openpgp.org/&gt; --search-keys &lt;user-id&gt;</span><br></pre></td></tr></table></figure><h1 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h1><h2 id="非对称加解密"><a href="#非对称加解密" class="headerlink" title="非对称加解密"></a>非对称加解密</h2><p>在加密（参数<code>--encrypt</code>或<code>-e</code>）一个文件或一条信息给另外一个人（参数<code>--recipient</code>或<code>-r</code>）之前，你需要先导入他的公钥。如果你还没有创建自己的密钥对，请先创建。</p><p>要加密一个名为 doc 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --recipient &lt;user-id&gt; --encrypt &lt;doc&gt;</span><br></pre></td></tr></table></figure><p>要解密（参数 <code>--decrypt</code> 或 <code>-d</code>）一个用你的公钥加密的、名为 <em>doc</em>.gpg 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output &lt;doc&gt; --decrypt &lt;doc.gpg&gt;</span><br></pre></td></tr></table></figure><p><em>gpg</em> 会提示你输入密钥口令，并将 <em>doc</em>.gpg 中的数据解密到 <em>doc</em>。如果你忽略了参数 <code>-o</code>（<code>--output</code>），<em>gpg</em> 将会直接输出解密的信息。</p><blockquote><p>提示：</p><ul><li>使用参数 <code>--armor</code> 以 ASCII 编码的形式加密文件（适用于复制与粘贴文本文件格式的消息）。</li><li>使用 <code>-R &lt;user-id&gt;</code> 或 <code>--hidden-recipient &lt;user-id&gt;</code> 代替 <code>-r</code> 可以不将收件人的指纹 ID 放入加密的消息中。这有助于隐藏收件人的信息，是针对流量分析的一个有限对策。</li><li>使用 <code>--no-emit-version</code> 以避免打印版本号。也可将相应配置添加到你的配置文件中。</li><li>你可以使用 GPG 将自己作为收件人来加密敏感文件，但是每次只能压缩一个文件——尽管你可以将多个文件压缩后再进行加密。如果需要加密一个目录或一整个文件系统，请参见 <a href="https://wiki.archlinuxcn.org/wiki/Data-at-rest_encryption#Available_methods" title="Data-at-rest encryption">Data-at-rest encryption#Available methods</a>。</li></ul></blockquote><h2 id="对称加解密"><a href="#对称加解密" class="headerlink" title="对称加解密"></a>对称加解密</h2><p>对称加密不需要生成密钥对，可用来简单地给文件加上密码。使用 <code>-c</code>&#x2F;<code>--symmetric</code> 参数来进行对称加密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg -c &lt;doc&gt;</span><br></pre></td></tr></table></figure><p>下面的例子：</p><ul><li>用口令给 <code>doc</code> 进行了对称加密</li><li>用 AES-256 加密算法对口令进行加密</li><li>用 SHA-512 摘要算法对口令进行打乱</li><li>打乱 65536 次</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg -c --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 --s2k-count 65536 doc</span><br></pre></td></tr></table></figure><p>下面的命令可解密以口令对称加密的 <code>doc.gpg</code> 文件，并将解密的文档输出到同一目录下的 <code>doc</code> 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output &lt;doc&gt; --decrypt &lt;doc&gt;.gpg</span><br></pre></td></tr></table></figure><p>解密时有时不需要输入密码，原因是 gpg-agent 缓存了。</p><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p>可用 <a href="https://man.archlinux.org/man/gpgtar.1">gpgtar(1)</a> 对目录进行加密和解密。</p><p>加密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpgtar -c -o &lt;dir.gpg&gt; &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure><p>解密：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpgtar -d &lt;dir.gpg&gt;</span><br></pre></td></tr></table></figure><h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><p>签名用于认证和时间戳文档。如果文档被修改，验证签名将失败。与使用公钥加密文档不同，签名是使用用户的私钥创建的。文档的接收者然后使用发送者的公钥验证签名。</p><h2 id="签署文件"><a href="#签署文件" class="headerlink" title="签署文件"></a>签署文件</h2><p>要签署文件，请使用<code>-s</code>&#x2F;<code>--sign</code>标志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output &lt;doc.sig&gt; --sign &lt;doc&gt;</span><br></pre></td></tr></table></figure><p><code>doc.sig</code>包含原始文件<code>doc</code>的压缩内容和以二进制格式表示的签名，但文件并未加密。但是，您可以将签名与加密结合使用。</p><h2 id="以可读形式签名文件或消息"><a href="#以可读形式签名文件或消息" class="headerlink" title="以可读形式签名文件或消息"></a>以可读形式签名文件或消息</h2><p>要签署文件而无需将其压缩为二进制格式，请使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output &lt;doc&gt;.sig --clearsign &lt;doc&gt;</span><br></pre></td></tr></table></figure><p>在这里，原始文件<code>doc</code>的内容和签名以可读形式存储在<code>doc.sig</code>中。</p><h2 id="创建独立的签名文件"><a href="#创建独立的签名文件" class="headerlink" title="创建独立的签名文件"></a>创建独立的签名文件</h2><p>要创建一个单独的签名文件，以便与文档或文件本身份开分发，请使用<code>--detach-sig</code>标志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --output &lt;doc.sig&gt; --detach-sig &lt;doc&gt;</span><br></pre></td></tr></table></figure><p>在这里，签名存储在<code>doc.sig</code>中，但<code>doc</code>的内容不会存储在其中。这种方法常用于分发软件项目，以允许用户验证程序未被第三方修改。</p><h2 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h2><p>要验证签名，请使用<code>--verify</code>标志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --verify &lt;doc.sig&gt;</span><br></pre></td></tr></table></figure><p>其中<code>doc.sig</code>是包含您要验证的签名的已签名文件。</p><p>如果您要验证一个已分离签名，验证时必须同时存在已签名的数据文件和签名文件。例如，要验证 Arch Linux 的最新 iso 文件，您可以执行以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --verify &lt;archlinux-version.iso.sig&gt;</span><br></pre></td></tr></table></figure><p>其中<code>archlinux-version.iso</code>必须位于相同的目录中。</p><p>您还可以使用第二个参数指定已签名的数据文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --verify &lt;archlinux-version.iso.sig&gt; &lt;/path/to/archlinux-version.iso&gt;</span><br></pre></td></tr></table></figure><p>如果一个文件除了被签名外还被加密，只需<a href="https://wiki.archlinuxcn.org/wiki/GnuPG#%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86">解密</a>该文件，其签名也将被验证。</p><h1 id="密钥维护"><a href="#密钥维护" class="headerlink" title="密钥维护"></a>密钥维护</h1><h2 id="备份你的私钥"><a href="#备份你的私钥" class="headerlink" title="备份你的私钥"></a>备份你的私钥</h2><p>用如下命令备份你的私钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --export-secret-keys --armor --output &lt;private-key.asc&gt; &lt;user-id&gt;</span><br></pre></td></tr></table></figure><p>请注意，上述命令将要求您输入密钥的密码。这是因为，否则任何获得上述导出文件访问权限的人都可以像您一样对文档进行加密和签名，而无需知道您的密码。</p><p><strong>警告：</strong></p><ul><li>口令通常是密钥安全方面最薄弱的环节。最好把导出的文件放在另一个系统或者设备里，比如物理保险柜或者加密驱动器中。这是当你遇到设备被盗、磁盘故障等情况时恢复对密钥控制权的唯一安全措施。</li><li>这种备份方式有一些安全局限性，这篇文章 <a href="https://web.archive.org/web/20210803213236/https://habd.as/post/moving-gpg-keys-privately/">https://web.archive.org/web/20210803213236/https://habd.as/post/moving-gpg-keys-privately/</a> 中有关于用 <em>gpg</em> 备份和导入密钥的更加安全的办法。</li></ul><p>用如下命令导入你的私钥备份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --import &lt;private-key.asc&gt;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong> 你可以用 <a href="https://wiki.archlinuxcn.org/wiki/Paperkey" title="Paperkey">Paperkey</a> 来把私钥导出为明文文本或条形码，并打印出来存档。</p><h2 id="备份你的吊销证书"><a href="#备份你的吊销证书" class="headerlink" title="备份你的吊销证书"></a>备份你的吊销证书</h2><p>若使用gpg公钥服务器</p><p>生成新密钥对的时候会同时生成吊销证书，默认存放在 <code>~/.gnupg/openpgp-revocs.d/</code> 下，证书的文件名是对应的密钥的指纹。 你也可以用以下命令手动生成吊销证书：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --gen-revoke --armor --output &lt;revcert.asc&gt; &lt;user-id&gt;</span><br></pre></td></tr></table></figure><p>如果密钥丢失或泄露，此证书可用于 <a href="https://wiki.archlinuxcn.org/wiki/GnuPG#%E5%90%8A%E9%94%80%E5%AF%86%E9%92%A5">#吊销密钥</a>。如果你无法访问密钥，则无法使用上述命令生成新的吊销证书，那么备份将非常有用。吊销证书很短，你可以把他打印出来然后在需要使用的时候手动输入到电脑里。</p><blockquote><p>警告：任何能接触到吊销证书的人都可以吊销你的密钥对，而且无法撤消。所以请像保护私钥一样保护你的吊销证书。</p></blockquote><h2 id="编辑你的密钥"><a href="#编辑你的密钥" class="headerlink" title="编辑你的密钥"></a>编辑你的密钥</h2><p>运行 <code>gpg --edit-key &lt;user-id&gt;</code> 命令将会出现一个菜单，该菜单使你能够执行大部分密钥管理相关的任务。</p><p>在编辑密钥子菜单中输入 <code>help</code> 命令可以显示完整的命令列表。以下是一些有用的命令：</p><blockquote><p>passwd       # 修改密码短语<br>clean        # 压缩任何不再可用的用户ID（例如已撤销或已过期）<br>revkey       # 撤销密钥<br>addkey       # 向该密钥添加子密钥<br>expire       # 更改密钥过期时间<br>adduid       # 添加附加的名称、注释和电子邮件地址<br>addphoto     # 向密钥添加照片（必须是JPG格式，推荐大小为240x288，当提示时输入完整路径）</p></blockquote><blockquote><p>提示：如果你有多个电子邮件账户，你可以使用 <code>adduid</code> 命令将每个账户都添加为一个身份。然后你可以将你最喜欢的账户设置为 <code>primary</code>。</p></blockquote><h2 id="删除密钥对"><a href="#删除密钥对" class="headerlink" title="删除密钥对"></a>删除密钥对</h2><p>删除私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --delete-secret-key &lt;user-id&gt;</span><br></pre></td></tr></table></figure><p>删除私钥后，需单独删除公钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --delete-key &lt;user-id&gt;</span><br></pre></td></tr></table></figure><p>校验：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gpg --list-keys</span><br><span class="line">gpg --list-secret-keys</span><br></pre></td></tr></table></figure><h1 id="gpg-agent"><a href="#gpg-agent" class="headerlink" title="gpg-agent"></a>gpg-agent</h1><p><em>gpg-agent</em> 主要用作守护进程，用于请求和缓存密钥链的密码。这在外部程序（如邮件客户端）使用 GnuPG 时十分有用。 <a href="https://archlinux.org/packages/?name=gnupg">gnupg</a>包 带有默认自动启动的 <a href="https://wiki.archlinuxcn.org/wiki/Systemd/%E7%94%A8%E6%88%B7" title="Systemd&#x2F;用户">systemd&#x2F;用户</a>套接字。这些套接字分别是 <code>gpg-agent.socket</code>、<code>gpg-agent-extra.socket</code>、<code>gpg-agent-browser.socket</code>、<code>gpg-agent-ssh.socket</code> 和 <code>dirmngr.socket</code>。</p><ul><li><em>gpg</em> 使用 <code>gpg-agent.socket</code> 连接到 <em>gpg-agent</em> 守护进程。</li><li><code>gpg-agent-extra.socket</code> 的作用是在本地建立一个转发自远程系统的 Unix 域套接字。这样就可以在远程系统上使用 <em>gpg</em>，而无需向远程系统公开私钥。有关详细信息，请参阅 <a href="https://man.archlinux.org/man/gpg-agent.1">gpg-agent(1)</a>。</li><li><code>gpg-agent-browser.socket</code> 允许 Web 浏览器访问 <em>gpg-agent</em> 守护进程。</li><li><a href="https://wiki.archlinuxcn.org/wiki/SSH" title="SSH">SSH</a> 使用 <code>gpg-agent-ssh.socket</code> 缓存 <em>ssh-add</em> 程序添加的 <a href="https://wiki.archlinuxcn.org/wiki/SSH_keys" title="SSH keys">SSH keys</a>。有关必要的配置，请参阅 <a href="https://wiki.archlinuxcn.org/wiki/GnuPG#SSH_agent">#SSH agent</a>。</li><li><code>dirmngr.socket</code> 启动一个 GnuPG 守护进程来处理与 keyserver 的连接。</li></ul><blockquote><p>注意：如果您没有使用默认的 GnuPG <a href="https://wiki.archlinuxcn.org/wiki/GnuPG#%E7%9B%AE%E5%BD%95%E4%BD%8D%E7%BD%AE">#目录位置</a>, 您需要<a href="https://wiki.archlinuxcn.org/wiki/Systemd#%E4%BF%AE%E6%94%B9%E7%8E%B0%E5%AD%98%E5%8D%95%E5%85%83%E6%96%87%E4%BB%B6" title="Systemd">编辑</a>所有套接字文件让其使用 <code>gpgconf --list-dirs</code> 的值。 套接字名称使用 <a href="https://github.com/gpg/gnupg/blob/260bbb4ab27eab0a8d4fb68592b0d1c20d80179c/common/homedir.c#L710-L713">非默认 GnuPG 主目录的哈希</a>，您可以硬编码它不用担心它的改变。</p></blockquote><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>gpg-agent 用 <code>~/.gnupg/gpg-agent.conf</code> 文件配置。配置选项列在 <a href="https://man.archlinux.org/man/gpg-agent.1">gpg-agent(1)</a> 中。例如，您可以更改默认密钥的缓存 ttl：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.gnupg/gpg-agent.conf</span><br><span class="line">---</span><br><span class="line">default-cache-ttl 3600</span><br></pre></td></tr></table></figure><blockquote><p>提示：要缓存整个会话的密码(passphrase)，请运行以下命令：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/gnupg/gpg-preset-passphrase --preset XXXXX</span><br></pre></td></tr></table></figure><p>其中 XXXXX 是 keygrip。您可以在运行 <code>gpg --with-keygrip -K</code> 时获取它的值。密码(passphrase)将一直保存到 <code>gpg-agent</code> 重新启动为止。如果设置了 <code>default-cache-ttl</code> 值，会优先采用它。</p><p>在 Linux 中，为了允许预设的密码短语，需要通过使用 <code>--allow-preset-passphrase</code> 启动 gpg-agent，或在 <code>~/.gnupg/gpg-agent.conf</code> 中设置<code>allow-preset-passphrase</code>。</p><h2 id="重新加载-gpg-agent"><a href="#重新加载-gpg-agent" class="headerlink" title="重新加载 gpg-agent"></a>重新加载 gpg-agent</h2><p>在修改完配置之后，用 <em>gpg-connect-agent</em> 重新加载 gpg-agent：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg-connect-agent reloadagent /bye</span><br></pre></td></tr></table></figure><p>该命令应该输出 <code>OK</code>。</p><p>但是在某些情况下，只是重新启动可能不够，比如当 <code>keep-screen</code> 被添加到 gpg-agent 配置中时。在这种情况下，您首先需要终止正在进行的 gpg-agent 进程，然后按上述方法重新启动它。</p><h2 id="pinentry"><a href="#pinentry" class="headerlink" title="pinentry"></a>pinentry</h2><p><code>gpg-agent</code> 可以在 <code>pinentry-program</code> 中设定，以便使用特定的 <a href="https://archlinux.org/packages/?name=pinentry">pinentry</a>包 用户界面来提示用户输入(passphrase)。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.gnupg/gpg-agent.conf</span><br><span class="line">---</span><br><span class="line">pinentry-program /usr/bin/pinentry-curses</span><br></pre></td></tr></table></figure><p>还有其他 pinentry 程序可选，参考 <code>pacman -Ql pinentry | grep /usr/bin/</code> 的输出结果。</p><blockquote><p>提示：</p><ul><li>为了使用 <code>/usr/bin/pinentry-kwallet</code> 您需要安装软件包 <a href="https://aur.archlinux.org/packages/kwalletcli/">kwalletcli</a>AUR。</li><li>所有的默认 pinentry 程序（除了 <code>/usr/bin/pinentry-emacs</code>）都支持 <a href="https://specifications.freedesktop.org/secret-service/">DBus Secret Service API</a> ，它允许通过一个兼容的管理器(如 <a href="https://wiki.archlinuxcn.org/wiki/GNOME_Keyring" title="GNOME Keyring">GNOME Keyring</a> 或 <a href="https://wiki.archlinuxcn.org/wzh/index.php?title=KeePass&action=edit&redlink=1" title="KeePass（页面不存在）">KeePassXC</a>)记住密码。</li></ul></blockquote><p>记得在修改完配置后要<a href="https://wiki.archlinuxcn.org/wiki/GnuPG#%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD_gpg-agent">#重新加载 gpg-agent</a>。</p><h2 id="缓存密码"><a href="#缓存密码" class="headerlink" title="缓存密码"></a>缓存密码</h2><p><code>max-cache-ttl</code> 和 <code>default-cache-ttl</code> 定义 gpg-agent 的密码缓存时间（秒）。要在会话中只输入一次密码，设置一个非常高的值即可，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gpg-agent.conf</span><br><span class="line">---</span><br><span class="line">max-cache-ttl 60480000</span><br><span class="line">default-cache-ttl 60480000</span><br></pre></td></tr></table></figure><p>对于 SSH 仿真模式下的密码缓存，需要设置 <code>default-cache-ttl-ssh</code> 和 <code>max-cache-ttl-ssh</code>，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gpg-agent.conf</span><br><span class="line">---</span><br><span class="line">default-cache-ttl-ssh 60480000</span><br><span class="line">max-cache-ttl-ssh 60480000</span><br></pre></td></tr></table></figure><h2 id="Unattended-passphrase"><a href="#Unattended-passphrase" class="headerlink" title="Unattended passphrase"></a>Unattended passphrase</h2><p>从 GnuPG 2.1.0 开始，需要使用 gpg-agent 和 pinentry，这可能会破坏使用 <code>--passphrase-fd 0</code> 命令行选项从 STDIN 传入的密码短语的向后兼容性。为了拥有与旧版本相同类型的功能，必须做两件事：</p><p>首先，编辑 gpg-agent 配置允许 <em>loopback</em> pinentry 模式 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.gnupg/gpg-agent.conf</span><br><span class="line">---</span><br><span class="line">allow-loopback-pinentry</span><br></pre></td></tr></table></figure><p>如果 gpg-agent 正在运行，<a href="https://wiki.archlinuxcn.org/wiki/GnuPG#%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD_gpg-agent">重新加载</a>它使配置生效。</p><p>其次，要么应用程序需要更新，以包括一个命令行参数来使用回环模式，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gpg --pinentry-mode loopback ...</span><br></pre></td></tr></table></figure><p>如果不可能这样做，则可以将选项添加到配置中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/.gnupg/gpg.conf</span><br><span class="line">---</span><br><span class="line">pinentry-mode loopback</span><br></pre></td></tr></table></figure><blockquote><p>上游作者指出，在 <code>gpg.conf</code> 中设置 <code>pinentry-mode loopback</code> 可能会破坏其他用法，如果可能，最好使用命令行选项。<br><a href="https://dev.gnupg.org/T1772">https://dev.gnupg.org/T1772</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> GNU/Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GPG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP与分布式系统</title>
      <link href="/fa2bcf65db26/"/>
      <url>/fa2bcf65db26/</url>
      
        <content type="html"><![CDATA[<p>参考：<br><a href="https://ieeexplore.ieee.org/abstract/document/6133253">https://ieeexplore.ieee.org/abstract/document/6133253</a><br><a href="https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/">https://www.infoq.cn/article/cap-twelve-years-later-how-the-rules-have-changed/</a></p><p>CAP理论三个特性：</p><ul><li><p>一致性（Consistency，C）：所有节点在同一时间看到相同的数据。</p></li><li><p>高可用（High Availability，A）：所有请求（读&#x2F;写）都能在合理时间内得到响应，即使部分节点出现故障。系统始终对外提供服务，不拒绝请求，但响应结果可能是旧数据或临时状态。</p></li><li><p>分区容忍性（Network Partition tolerance，P）：网络分区（Network Partition）发生时，导致部分节点之间通信中断，系统也不会停止服务，仍能继续运行。</p></li></ul><h1 id="“三选二”的表述过于简化，忽略了分区（P）的必然性"><a href="#“三选二”的表述过于简化，忽略了分区（P）的必然性" class="headerlink" title="“三选二”的表述过于简化，忽略了分区（P）的必然性"></a>“三选二”的表述过于简化，忽略了分区（P）的必然性</h1><p>P 是 Network Partition tolerance，指的是要求分布式系统中存在部分节点、子网路无法访问时，系统依然能正常提供服务。</p><p>CAP“三选二”的说法本身具有一定误导性。CAP被广泛描述为“一致性、可用性、分区容忍性三者只能选其二”，但这种表述容易让人误以为分区（P）是一个可选项，甚至可以完全避免。</p><p>如果 P 可以舍弃，就有两种可能：  </p><ol><li>网路绝对可靠、系统中没有节点会出错（现实世界绝对不可能，除非单个节点）</li><li>当分区事件出现，系统不再正常提供服务（集群单个节点出现问题，整个系统停止）</li></ol><p>实际上，<strong>分区（P）是分布式系统中必须接受的现实</strong>。网络故障、节点宕机、跨数据中心通信等问题在分布式系统中不可避免。因此，真正的选择是在一致性（C）和可用性（A）之间权衡，而不是“三选二”。</p><p>两个节点发生分区时且有具有分区容忍（P）的情况下，要么阻止数据写入（只读状态）以保证数据的一致性（CP系统）；要么允许部分节点写入而导致产生数据的不一致性（AP系统），由此网络分区（P）下的CA几乎不能完成。</p><h1 id="忽略了分区发生的频率和业务场景的灵活性"><a href="#忽略了分区发生的频率和业务场景的灵活性" class="headerlink" title="忽略了分区发生的频率和业务场景的灵活性"></a>忽略了分区发生的频率和业务场景的灵活性</h1><p>CAP理论被解读为“所有场景下只能选C或A”，但实际系统设计中，<strong>分区发生的频率远低于正常运行状态</strong>。</p><p><strong>在大多数时间，系统可以同时满足CA</strong>：<br>当网络分区未发生时，系统可以追求强一致性和高可用性（CA）。例如，单数据中心内的数据库集群在正常运行时，通常可以同时满足CA。</p><p><strong>分区时的动态权衡</strong>：<br>CAP理论的核心矛盾仅在分区发生时才显现。此时，系统需要根据业务需求选择CP或AP，而不是全局静态选择。</p><p>e.g.<br>Google Spanner通过强一致性（CP）设计，但在全球范围内极少发生分区（依赖专网和原子钟同步），因此在实际中可以“假装”是CA系统。</p><p>此外，当客户端和服务端发生分区时，高可用必是不存在的，服务无法对外提供访问。</p><h1 id="忽视了C和A的可量化性"><a href="#忽视了C和A的可量化性" class="headerlink" title="忽视了C和A的可量化性"></a>忽视了C和A的可量化性</h1><p>CAP理论被简化为“非此即彼”的二元对立（C vs. A），但实际上<strong>一致性和可用性都可以以不同粒度实现</strong>。</p><p><strong>一致性（C）的层级</strong>：<br>从强一致性（线性一致性）到最终一致性，存在多种中间状态。例如，NoSQL数据库支持“最终一致性”，而区块链使用“拜占庭容错”算法。</p><p><strong>可用性（A）的层级</strong>：<br>可用性并非100%的绝对值，而是可以量化为“99.99%可用”或“部分可用”。例如，12306订票系统在极端情况下允许“基本可用”，而非完全不可用。</p><p>e.g.<br>在电商系统中，购物车服务可以容忍短时间的数据不一致（AP），而支付服务必须保证强一致性（CP）。</p><h1 id="忽略了网络延迟和分布式系统的复杂性"><a href="#忽略了网络延迟和分布式系统的复杂性" class="headerlink" title="忽略了网络延迟和分布式系统的复杂性"></a>忽略了网络延迟和分布式系统的复杂性</h1><p>CAP理论的原始表述<strong>忽略了网络延迟和数据复制的时间开销</strong>，导致对一致性的理解过于理想化。</p><p><strong>网络延迟的必然性</strong>：<br>即使在无分区的情况下，数据从节点A复制到节点B也需要时间。CAP理论中的“一致性”要求数据瞬间同步，这在现实中是不可能的。我们无法判断是网络延迟导致节点间无法通讯还是网络分区导致的。<br>此时有两个选择，一个是继续等待，另一个是忽略风险继续操作。如：Paxos将会无限地将决策进行延期（CP）。</p><p><strong>PACELC理论</strong>（Partition-tolerance, Availability, Consistency Else Latency, Consistency）扩展了CAP，指出：</p><ul><li><strong>当发生分区时</strong>（P），在A和C之间权衡；</li><li><strong>当无分区时</strong>（E），在延迟（L）和一致性（C）之间权衡。例如，MySQL在无分区时通过主从复制实现高一致性，但需要容忍一定的延迟。</li></ul><h1 id="忽视了工程实践中的折中方案"><a href="#忽视了工程实践中的折中方案" class="headerlink" title="忽视了工程实践中的折中方案"></a>忽视了工程实践中的折中方案</h1><p>CAP理论被解读为“必须严格选择CP或AP”，但实际系统设计中存在大量<strong>折中策略</strong>。</p><p><strong>混合架构</strong>：<br>系统可以针对不同模块选择不同的策略。例如，金融交易模块选择CP（强一致性），而推荐系统模块选择AP（高可用性）。</p><p><strong>算法优化</strong>：<br>通过Paxos、Raft等共识算法，在分区发生时实现“最终一致性”，既保障可用性，又逐步恢复一致性。</p><h1 id="管理网络分区"><a href="#管理网络分区" class="headerlink" title="管理网络分区"></a>管理网络分区</h1><p>系统设计者的挑战在于缓和系统分区对一致性和可用性带来的影响。核心思路是显式地管理网络分区，不仅包括探测，还需要一个特定的恢复程序，以及一个计划来应对分区过程中系统不变性被打破的情况。这个管理过程有三个步骤：</p><ul><li>特测到分区的发生</li><li>进入显式的分区状态，并限制部分操作</li><li>当通信恢复时，启动分区恢复过程</li></ul><p>最后一步的作用是重建一致性，并为系统分区时程序造成的错误进行补偿。</p><p>分区的演化过程：正常的操作由一系列原子操作构成，因而分区总是出现在操作之间。一旦系统发现超时，便检测到了分区，而发现分区的这一侧进入分区状态。如果分区确实存在，那么分区的两侧都会进入分区模式，不过单侧分区也不是不可能。在这种情况下，对侧根据需要发起通信，本侧可能正常回复，也可能不需要回复，这两种情况都能保持一致性。不过，由于感知到分区的一侧有可能会发生不一致的操作，所以其必须进入分区模式。使用“众数”机制的系统就是单侧分区的例子。一侧拥有众数，可以正常工作，而另一侧不行。支持离线操作的系统显然有分区模式的概念，有些原子广播的系统，比如Java的JGroups也是一样。</p><p>设计系统中进行分区管理需要考虑的问题：<br>问题1：哪些操作可以继续，哪些操作在分区合并之后仍然保证其准确性？<br>问题2：分区恢复时如何合并分区？<br>问题3：如何补偿在分区阶段造成的错误？</p><hr><p>e.g.<br>ATM机上的补偿问题<br>在ATM（自动柜员机）的设计中，强一致性看似符合逻辑的选择，但现实情况是可用性远比一致性重要。理由很简单：高可用性意味着高收入。不管怎么样，讨论如何补偿分区期间被破坏的不变性约束，ATM 的设计很适合作为例子。</p><p>ATM 的基本操作是存款、取款、查看余额。关键的不变性约束是余额应大于或等于零。因为只有取款操作会触犯这项不变性约束，也就只有取款操作将受到特别对待，其他两种操作随时都可以执行。</p><p>ATM 系统设计师可以选择在分区期间禁止取款操作，因为在那段时间里没办法知道真实的余额，当然这样会损害可用性。现代 ATM 的做法正相反，在 stand-in 模式下（即分区模式），ATM 限制净取款额不得高于 k，比如 k 为 $200。低于限额的时候，取款完全正常；当超过限额的时候，系统拒绝取款操作。这样，ATM 成功将可用性限制在一个合理的水平上，既允许取款操作，又限制了风险。</p><p>分区结束的时候，必须有一些措施来恢复一致性和补偿分区期间系统所造成的错误。状态的恢复比较简单，因为操作都是符合交换率的，补偿就要分几种情况去考虑。最后的余额低于零违反了不变性约束。由于 ATM 已经把钱吐出去了，错误成了外部实在。银行的补偿办法是收取透支费并指望顾客偿还。因为风险已经受到限制，问题并不严重。还有一种情况是分区期间的某一刻余额已经小于零（但 ATM 不知道），此时一笔存款重新将余额变为正的。银行可以追溯产生透支费，也可以因为顾客已经缴付而忽略该违反情况。</p><p>总的来说，由于通信的延迟，银行系统并不依靠一致性来获取正确性，而是基于审计和补偿。另一个例子是支票风筝（check kiting），意思是客户从多个支行取走现金，在它们彼此通信之前就溜之大吉。这种透支后面会被抓到，并导致法律层面上的补偿。</p><hr><p>e.g.<br>飞机上刷Visa卡的过程可以被视为网络分区的一个体现，飞机在飞行中通常无法连接地面网络（如国际航班无蜂窝网络），导致支付终端与银行系统之间形成逻辑网络分区。其实这个过程与ATM机的例子差不多。</p><p>策略1：可用性优先（AP系统）</p><ul><li>分区期间的操作：飞机上的支付终端可能允许乘客离线刷卡（如预授权模式），记录交易数据并暂存。例如，某些航班允许乘客购买餐食或商品，飞行前冻结一定金额，确保乘客在飞行中刷卡时账户余额足够。分区恢复后，银行根据实际消费金额调整冻结金额。（Pre-Authorization）。</li><li>分区恢复后的补偿：飞机着陆后，终端通过地面网络将交易数据批量上传至银行系统。若账户余额不足或卡片无效，银行需通过补偿机制修正错误。如：重复交易补偿、透支处理。</li></ul><p>策略2：一致性优先（CP系统）</p><ul><li>分区期间的限制：若系统强制要求实时验证（如高风险交易），则分区期间可能拒绝所有刷卡请求，牺牲可用性。例如，某些航班仅允许现金支付，或禁止高额度信用卡交易。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL架构及SQL执行流程、优化</title>
      <link href="/3a827e313e2d/"/>
      <url>/3a827e313e2d/</url>
      
        <content type="html"><![CDATA[<p>参考：<br><a href="https://developer.aliyun.com/article/1575323">全解MySQL之架构篇：自顶向下深入剖析MySQL整体架构！</a><br><a href="https://xiaolincoding.com/mysql/base/how_select.html#%E7%AC%AC%E4%BA%8C%E6%AD%A5-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98">执行一条 select 语句，期间发生了什么？</a><br><a href="https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html">SQL语句在MySQL中的执行过程</a><br><a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%28%E9%BB%84%E5%B1%B1%E7%89%88%29.pdf">Java开发手册(黄山版)</a><br><a href="https://www.cnblogs.com/juno3550/p/14887672.html">MySQL 慢 SQL &amp; 优化方案</a><br><a href="https://developer.aliyun.com/article/1008410">老司机总结的12条 SQL 优化方案</a><br><a href="https://blog.csdn.net/guoqi_666/article/details/122484535">sql优化的15个小技巧</a></p><h1 id="一、MySQL架构"><a href="#一、MySQL架构" class="headerlink" title="一、MySQL架构"></a>一、MySQL架构</h1><p>MySQL Architecture with Pluggable Storage Engines:<br><a href="https://dev.mysql.com/doc/refman/8.4/en/images/mysql-architecture.png">https://dev.mysql.com/doc/refman/8.4/en/images/mysql-architecture.png</a><br><img src="https://dev.mysql.com/doc/refman/8.4/en/images/mysql-architecture.png"></p><p>从上往下看，依次会分为网络连接层、系统服务层、存储引擎层、以及文件系统层</p><ul><li>网络连接层：主要是指数据库连接池，会负责处理所有客户端接入的工作。</li><li>服务层：主要包含<code>SQL</code>接口、解析器、优化器以及缓存缓冲区四块区域。</li><li>存储引擎层：这里是指<code>MySQL</code>支持的各大存储引擎，如<code>InnoDB、MyISAM</code>等。</li><li>文件系统层：涵盖了所有的日志，以及数据、索引文件，位于系统硬盘上。</li></ul><h2 id="网络连接层"><a href="#网络连接层" class="headerlink" title="网络连接层"></a>网络连接层</h2><p>当一个客户端尝试与<code>MySQL</code>建立连接时，<code>MySQL</code>内部都会派发一条线程负责处理该客户端接下来的所有工作。而数据库的连接层负责的就是所有客户端的接入工作。若数据库连接建立成功，<code>MySQL</code>会“安排”一条线程维护当前客户端的连接，这条线程也会时刻标识着当前连接在干什么工作，可以通过<code>show processlist;</code>命令查询所有正在运行的线程及其工作详情。</p><p>连接建立成功后，<code>MySQL</code>与客户端之间会采用半双工的通讯机制工作。</p><blockquote><ul><li>全双工：代表通讯的双方在同一时间内，即可以发送数据，也可以接收数据。</li><li>半双工：代表同一时刻内，单方要么只能发送数据，要么只能接受数据。</li><li>单工：当前连接只能发送数据或只能接收数据，也就是“单向类型的通道”。</li></ul></blockquote><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>每个客户端连接数据库都需要一条线程去维护，但创建新的线程是需要一定的资源消耗的，而且线程资源不可能无限量创建。</p><p><code>Connection Pool</code>的存在主要是为了复用线程、管理线程以及限制最大连接数的。一方面提升了性能，第二方面还节省了一定程度上的资源开销。</p><p>连接池的最大线程数可以通过参数<code>max-connections</code>来控制，如果到来的客户端连接超出该值时，新到来的连接都会被拒绝，关于最大连接数的一些命令主要有两条：</p><ul><li><code>show variables like &#39;%max_connections%&#39;;</code>：查询目前<code>DB</code>的最大连接数。</li><li><code>set GLOBAL max_connections = 200;</code>：修改数据库的最大连接数为指定值。</li></ul><p>对于不同的机器配置，可以适当的调整连接池的最大连接数大小，以此可以在一定程度上提升数据库的性能。除了可以查询最大连接数外，<code>MySQL</code>本身还会对客户端的连接数进行统计，对于这点可以通过命令<code>show status like &quot;Threads%&quot;;</code>查询。</p><h2 id="系统服务层"><a href="#系统服务层" class="headerlink" title="系统服务层"></a>系统服务层</h2><p><code>MySQL</code>大多数核心功能都位于这一层，包括客户端<code>SQL</code>请求解析、语义分析、查询优化、缓存以及所有的内置函数（例如：日期、时间、统计、加密函数…），所有跨引擎的功能都在这一层实现，譬如存储过程、触发器和视图等一系列服务。</p><p>主要包含<code>SQL</code>接口（SQL Interface）、解析器（Parser）、优化器（Optimizer）以及缓存（Caches&amp;Buffers）相关的这些部分。</p><h3 id="SQL接口"><a href="#SQL接口" class="headerlink" title="SQL接口"></a>SQL接口</h3><p><code>SQL</code>接口组件的主要作用就是负责处理客户端的<code>SQL</code>语句，当客户端连接建立成功之后，会接收客户端的<code>SQL</code>命令，比如<code>DML、DDL</code>语句以及存储过程、触发器等，当收到<code>SQL</code>语句时，<code>SQL</code>接口会将其分发给其他组件，然后等待接收执行结果的返回，最后会将其返回给客户端。</p><blockquote><p>简单来说，也就是<code>SQL</code>接口会作为客户端连接传递<code>SQL</code>语句时的入口，并且作为数据库返回数据时的出口。</p></blockquote><p>对于这个组件主要有两个作用，第一是对于<code>SQL</code>语句的类型划分，第二则是触发器。</p><p>根据<code>SQL</code>的不同的作用，<code>SQL</code>分为五大类：</p><ul><li><code>DML</code>：数据库操作语句，比如<code>update、delete、insert</code>等都属于这个分类。</li><li><code>DDL</code>：数据库定义语句，比如<code>create、alter、drop</code>等都属于这个分类。</li><li><code>DQL</code>：数据库查询语句，比如最常见的<code>select</code>就属于这个分类。</li><li><code>DCL</code>：数据库控制语句，比如<code>grant、revoke</code>控制权限的语句都属于这个分类。</li><li><code>TCL</code>：事务控制语句，例如<code>commit、rollback、setpoint</code>等语句属于这个分类。</li></ul><p>再来聊一聊<code>MySQL</code>的触发器，这东西估计大部分小伙伴没用过，但它在有些情景下还较为实用，不过想要了解触发器是什么，首先咱们还得先理解存储过程。</p><blockquote><p>存储过程：是指提前编写好的一段较为常用或复杂<code>SQL</code>语句，然后指定一个名称存储起来，然后先经过编译、优化，完成后，这个“过程”会被嵌入到<code>MySQL</code>中。</p></blockquote><p>也就是说，存储过程的本质就是一段预先写好并编译完成的<code>SQL</code>，而我们要聊的触发器则是一种特殊的存储过程，但 触发器 与 存储过程 的不同点在于：<strong>存储过程需要手动调用后才可执行，而触发器可由某个事件主动触发执行</strong>。<br>在<code>MySQL</code>中支持<code>INSERT、UPDATE、DELETE</code>三种事件触发，同时也可以通过<code>AFTER、BEFORE</code>语句声明触发的时机，是在操作执行之前还是执行之后。</p><blockquote><p>说简单一点，<code>MySQL触发器</code>就类似于<code>Spring</code>框架中的<code>AOP</code>切面。</p></blockquote><h3 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h3><p>客户端连接发送的<code>SQL</code>语句，经过<code>SQL</code>接口后会先被分发到解析器，解析器这东西其实在所有语言中都存在，<code>Java、C、Go...</code>等其他语言都有，解析器的作用主要是做词法分析、语义分析、语法树生成…这类工作的，<code>Java</code>源码在编写后，会经历这个过程，<code>SQL</code>语言同样类似。</p><p>而解析器这一步的作用主要是为了验证<code>SQL</code>语句是否正确，以及将<code>SQL</code>语句解析成<code>MySQL</code>能看懂的机器码指令。稍微拓展一点大家就明白了，好比如我们编写如下一条<code>SQL</code>：</p><blockquote><p><code>select * form user;</code></p></blockquote><p>然后运行会得到如下错误信息：</p><blockquote><p><code>ERROR 1064 (42000): You have an error in your SQL syntax; check....</code></p></blockquote><p>在上述<code>SQL</code>中，我们将<code>from</code>写成了<code>form</code>，结果运行时<code>MySQL</code>提示语法错误了，<code>MySQL</code>是如何发现的呢？就是在词法分析阶段，检测到了存在语法错误，因此抛出了对应的错误码及信息。当然，如果<code>SQL</code>正确，则会进行下一步工作，生成<code>MySQL</code>能看懂的执行指令。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>解析器完成相应的词法分析、语法树生成….等一系列工作后，紧接着会来到优化器，优化器的主要职责在于生成执行计划，比如选择最合适的索引，选择最合适的<code>join</code>方式等，最终会选择出一套最优的执行计划。</p><blockquote><p>当然，在这里其实有很多资料也会聊到，存在一个执行器的抽象概念，实际上执行器是不存在的，因此前面聊到过，每个客户端连接在<code>MySQL</code>中都用一条线程维护，而线程是操作系统的最小执行单位，因此所谓的执行器，本质上就是线程本身。</p></blockquote><p>优化器生成了执行计划后，维护当前连接的线程会负责根据计划去执行<code>SQL</code>，这个执行的过程实际上是在调用存储引擎所提供的<code>API</code>。</p><h3 id="缓存-缓冲"><a href="#缓存-缓冲" class="headerlink" title="缓存&amp;缓冲"></a>缓存&amp;缓冲</h3><p>这块主要分为了读取缓存与写入缓冲；</p><blockquote><p><code>mysql 8.0+</code>已经完全移除Caches模块，以下相关命令不起作用；<br>在我的<code>mariadb 10.6.21</code>中，这个功能还保留着；</p></blockquote><p>读取缓存主要是指<code>select</code>语句的数据缓存，当然也会包含一些权限缓存、引擎缓存等信息，但主要还是<code>select</code>语句的数据缓存。<br>设计初衷是提高性能，通过缓存来减少解析器、优化器、存储引擎的执行时间。</p><p>对于<code>Cache</code>是否开启可通过命令查询：</p><ul><li><code>show global variables like &quot;%query_cache_type%&quot;;</code>：查询缓存是否开启。</li><li><code>show global variables like &quot;%query_cache_size%&quot;;</code>：查询缓存的空间大小。</li></ul><p>同时还可以通过<code>show status like&#39;%Qcache%&#39;;</code>命令查询缓存相关的统计信息。</p><p>MySQL查询缓存原理<br>MySQL查询缓存是一个查询结果缓存。它将以<code>SEL</code>开头的传入查询与哈希表进行比较，如果匹配，则返回上一次执行查询的结果。<br>就是将查询<code>SQL</code>进行<code>Hash</code>处理，然后将结果存进内存，假如第二次查询<code>SQLHash</code>值存在，那么直接从内存中读取，加快查询的速率。</p><p>为什么MySQL要放弃查询缓存？</p><ol><li>对于 <code>Select * from stu</code>与<code>select * from stu</code> 由于Hash的结果不同，所以查询缓存不会被命中，对于复杂的业务场景这种情况可能会大量发生。</li><li>查询缓存会在表增删改的情况下失效，所以查询缓存适合读多写少的场景，QueryCache理想的场景往往是只读的。</li><li>对于表分区默认查询缓存关闭。</li><li>对于未命中缓存的Sql，会进行数据写入，官方统计会消耗13%的资源。</li><li>对于某些的函数，查询缓存也不会生效，比如 now()</li></ol><hr><p>简单了解了查询缓存后，再来看看写入缓冲；<br>缓冲区的设计主要是：<strong>为了通过内存的速度来弥补磁盘速度较慢对数据库造成的性能影响</strong>。在数据库中读取某页数据操作时，会先将从磁盘读到的页存放在缓冲区中，后续操作相同页的时候，可以基于内存操作。</p><p>一般来说，当你对数据库进行写操作时，都会先从缓冲区中查询是否有你要操作的页，如果有，则直接对内存中的数据页进行操作（例如修改、删除等），对缓冲区中的数据操作完成后，会直接给客户端返回成功的信息，然后<code>MySQL</code>会在后台利用一种名为<code>Checkpoint</code>的机制，将内存中更新的数据刷写到磁盘。</p><blockquote><p><code>MySQL</code>在设计时，通过缓冲区能减少大量的磁盘<code>IO</code>，从而进一步提高数据库整体性能。毕竟每次操作都走磁盘，性能自然上不去的。</p></blockquote><p><em>PS：后续高版本的<code>MySQL</code>移除了查询缓存区，但并未移除缓冲区，这是两个概念，请切记！</em></p><blockquote><p>同时缓冲区是与存储引擎有关的，不同的存储引擎实现也不同，比如<code>InnoDB</code>的缓冲区叫做<code>innodb_buffer_pool</code>，而<code>MyISAM</code>则叫做<code>key_buffer</code></p></blockquote><h2 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h2><p>存储引擎也可以理解成<code>MySQL</code>最重要的一层，在前面的服务层中，聚集了<code>MySQL</code>所有的核心逻辑操作，而引擎层则负责具体的数据操作以及执行工作。</p><p>如果有小伙伴研究过<code>Oracle、SQLServer</code>等数据库的实现，应该会发现这些数据库只有一个存储引擎，因为它们是闭源的，所以仅有官方自己提供的一种引擎。而<code>MySQL</code>则因为其开源特性，所以存在很多很多款不同的存储引擎实现，<code>MySQL</code>为了能够正常搭载不同的存储引擎运行，因此引擎层是被设计成可拔插式的，也就是可以根据业务特性，为自己的数据库选择不同的存储引擎。</p><blockquote><p><code>MySQL</code>的存储引擎主要分为官方版和民间版，前者是<code>MySQL</code>官方开发的，后者则是第三方开发的。存储引擎在<code>MySQL</code>中，相关的规范标准被定义成了一系列的接口，如果你也想要使用自己开发的存储引擎，那么只需要根据<code>MySQL AB</code>公司定义的准则，编写对应的引擎实现即可。</p></blockquote><p><code>MySQL</code>目前有非常多的存储引擎可选择，其中最为常用的则是<code>InnoDB</code>与<code>MyISAM</code>引擎，可以通过<code>show variables like &#39;%storage_engine%&#39;;</code>命令来查看当前所使用的引擎。</p><p>其他常见引擎如下：</p><ol><li><strong>InnoDB</strong>：默认事务型引擎，支持<strong>ACID 事务</strong>、行级锁定和外键约束，适用于高并发、数据完整性要求高的场景。</li><li><strong>MyISAM</strong>：非事务型引擎，优化<strong>读取性能</strong>，但不支持事务和行级锁定，适合读多写少的场景。</li><li><strong>NDB (Network Database)</strong>：分布式引擎，用于<strong>集群环境</strong>，提供高可用性和负载均衡，常用于需要高可靠性的应用。</li><li><strong>Archive</strong>：专为<strong>数据归档</strong>设计，仅支持 <code>INSERT</code> 和 <code>SELECT</code>，数据压缩存储，节省空间。</li><li><strong>Federated</strong>：允许<strong>跨服务器访问</strong>远程 MySQL 数据库的表，类似“分布式表”的功能。</li><li><strong>Memory</strong>：将数据存储在<strong>内存</strong>中，提供高速读写，但重启后数据会丢失，适合临时数据。</li><li><strong>Merge</strong>：将多个<strong>MyISAM 表</strong>合并为一个逻辑表，便于统一查询和管理大规模数据。</li><li><strong>Partner&#x2F;Community</strong>：指<strong>第三方或社区开发的引擎</strong>（如 tokudb、rocksdb 等），需额外安装或集成。</li></ol><p>存储引擎是<code>MySQL</code>数据库中与磁盘文件打交道的子系统，不同的引擎底层访问文件的机制也存在些许细微差异，引擎也不仅仅只负责数据的管理，也会负责库表管理、索引管理等，<code>MySQL</code>中所有与磁盘打交道的工作，最终都会交给存储引擎来完成。</p><h2 id="文件系统层"><a href="#文件系统层" class="headerlink" title="文件系统层"></a>文件系统层</h2><p>这一层主要可分为两个板块：</p><ul><li>日志板块。</li><li>数据板块。</li></ul><p>这一层则是<code>MySQL</code>数据库的基础，本质上就是基于机器物理磁盘的一个文件系统，其中包含了配置文件、库表结构文件、数据文件、索引文件、日志文件等各类<code>MySQL</code>运行时所需的文件，这一层的功能比较简单，也就是与上层的存储引擎做交互，负责数据的最终存储与持久化工作。</p><h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><p>在<code>MySQL</code>中主要存在七种常用的日志类型，如下：</p><ul><li>①<code>binlog</code>二进制日志，主要记录<code>MySQL</code>数据库的所有<strong>写操作</strong>（增删改）。</li><li>②<code>redo-log</code>重做&#x2F;重写日志，<code>MySQL</code>崩溃时，对于未落盘的操作会记录在这里面，用于重启时重新落盘（<code>InnoDB</code>专有的）。</li><li>③<code>undo-logs</code>撤销&#x2F;回滚日志：记录事务开始前[修改数据]的备份，用于回滚事务。</li><li>④<code>error-log</code>：错误日志：记录<code>MySQL</code>启动、运行、停止时的错误信息。</li><li>⑤<code>general-log</code>常规日志，主要记录<code>MySQL</code>收到的每一个查询或<code>SQL</code>命令。</li><li>⑥<code>slow-log</code>：慢查询日志，主要记录执行时间较长的<code>SQL</code>。</li><li>⑦<code>relay-log</code>：中继日志，主要用于主从复制做数据拷贝。</li></ul><p>上述列出了<code>MySQL</code>中较为常见的七种日志，但实际上还存在很多其他类型的日志，不过一般对调优、排查问题、数据恢复&#x2F;迁移没太大帮助，用的较少，因此不再列出。</p><h3 id="数据模块"><a href="#数据模块" class="headerlink" title="数据模块"></a>数据模块</h3><p>前面聊到过，<code>MySQL</code>的所有数据最终都会落盘（写入到磁盘），而不同的数据在磁盘空间中，存储的格式也并不相同，因此再列举出一些<code>MySQL</code>中常见的数据文件类型：</p><ul><li><code>db.opt</code>文件：主要记录当前数据库使用的字符集和验证规则等信息。</li><li><code>.frm</code>文件：存储表结构的元数据信息文件，每张表都会有一个这样的文件。</li><li><code>.MYD</code>文件：用于存储表中所有数据的文件（<code>MyISAM</code>引擎独有的）。</li><li><code>.MYI</code>文件：用于存储表中索引信息的文件（<code>MyISAM</code>引擎独有的）。</li><li><code>.ibd</code>文件：用于存储表数据和索引信息的文件（<code>InnoDB</code>引擎独有的）。</li><li><code>.ibdata</code>文件：用于存储共享表空间的数据和索引的文件（<code>InnoDB</code>引擎独有）。</li><li><code>.ibdata1</code>文件：这个主要是用于存储<code>MySQL</code>系统（自带）表数据及结构的文件。</li><li><code>.ib_logfile0/.ib_logfile1</code>文件：用于故障数据恢复时的日志文件。</li><li><code>.cnf/.ini</code>：<code>MySQL</code>的配置文件，<code>Windows</code>下是<code>.ini</code>，其他系统大多为<code>.cnf</code>。</li><li><code>......</code></li></ul><p>上述列举了一些<code>MySQL</code>中较为常见的数据文件类型，无论是前面的日志文件，亦或是现在的数据文件，这些都是后续深入剖析<code>MySQL</code>时会遇到的，因此在这里先有个简单认知，方便后续更好的理解<code>MySQL</code>。</p><h1 id="二、SQL查询语句执行流程"><a href="#二、SQL查询语句执行流程" class="headerlink" title="二、SQL查询语句执行流程"></a>二、SQL查询语句执行流程</h1><p><a href="https://mermaid-live.nodejs.cn/edit#pako:eNptkl1P2lAYx7_KyUm8A0Lpi6XZTMZ8wftdrfWiWauYSEu6NtlGSeZ0BiMSVDCYbWw4jWQLhWTZuwsfZpzT9lvslCODoOfq_J_n__yfX05OET4xNR1KcMNSCznwaFExADlzc-B-dEAwaOHqZdj8hr2vtEQND2TknePyd_9zbw3ci8cXQEamXnTWWaOeDIjqru-1_doebf59uY3f7YRntfBTJehtE4nKe-HrQ__XwO8cuEtycPURt2o0YxZl1LqNskTXBL1D_KVB4oiJ5Aa97n8ZX_Dr73G5RhPwhyMXLMvh-S662CVkE-DlcVJ3-HOfmmeAx0n4tD8VtiIPr5uocnonNm0Nf1Tx_lXQrtzmX7l5Jho8MgVeG5WPXZCVqZ4gZm8Q-zt-vYO6TfSqg64b-KTqglV5Ws_4B3X0phV4ffSn4YIM7c2A-r9PcOstdU7zrd4VkVUMGCOfZlODkm05egzmdSuvRhIWozkF2jk9rytQIldNX1edLVuBilEiYwXVeGya-fGkZTobOSitq1tPiXIKmmrri5sq-ZETi25ouvXQdAwbSvwoAUpF-AxKTJJLiCyXFlkxxQsiK8Tg86g6n5jnGI5Ni0yaZfk0V4rBF6OdyYSYZFIphhcFQWBFPiWU_gGnlliL">一图流</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    %% ===== 连接阶段 =====</span><br><span class="line">    A[客户端] &lt;--&gt; B[连接器]</span><br><span class="line">    B --&gt; |管理连接、权限验证、分配线程|E[解析器]</span><br><span class="line"></span><br><span class="line">    %% ===== 解析阶段 =====</span><br><span class="line">    E --&gt; |词法分析、语法分析-&gt;生成解析树| F[预处理器]</span><br><span class="line">    F --&gt; |语义解析、权限验证-&gt;生成新解析树| G[优化器]</span><br><span class="line"></span><br><span class="line">    %% ===== 优化与执行阶段 =====</span><br><span class="line">    G --&gt; |生成执行计划| H[执行器]</span><br><span class="line">    H --&gt; |调用存储引擎| I[存储引擎]</span><br><span class="line">    H --&gt; |返回记录| B</span><br><span class="line">    </span><br><span class="line">    %% ===== 结果返回 =====</span><br><span class="line">    I --&gt; |返回记录| H</span><br></pre></td></tr></table></figure><h2 id="第一步：连接器"><a href="#第一步：连接器" class="headerlink" title="第一步：连接器"></a>第一步：连接器</h2><p>客户端通过TCP&#x2F;IP等协议发送SQL请求。服务端接收到请求，转交给连接器处理。</p><p>连接器就要开始验证用户的用户名和密码，如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p><p>然后为该连接创建新线程或复用线程连接池中的线程，若连接数已达上限则返回错误。</p><h2 id="第二步：查询缓存"><a href="#第二步：查询缓存" class="headerlink" title="第二步：查询缓存"></a>第二步：查询缓存</h2><blockquote><p>MySQL 8.0+ 已经删除查询缓存功能</p></blockquote><p>建立连接后，会把SQL语句发给<code>SQL Interface</code>，他会解析出 SQL 语句的第一个字段，看看是什么类型的语句。</p><p>如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。</p><p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p>这么看，查询缓存还挺有用，但是其实查询缓存挺鸡肋的。</p><p>对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。</p><blockquote><p>这里说的查询缓存是 server 层的，并不是 Innodb 存储引擎中的 buffer pool。</p></blockquote><h2 id="第三步：解析-SQL"><a href="#第三步：解析-SQL" class="headerlink" title="第三步：解析 SQL"></a>第三步：解析 SQL</h2><p>在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成。</p><h3 id="解析器-1"><a href="#解析器-1" class="headerlink" title="解析器"></a>解析器</h3><p><strong>词法分析</strong>：将SQL语句拆分为Token（如关键字<code>SELECT</code>、表名<code>users</code>、运算符<code>=</code>）。</p><p><strong>语法分析</strong>：验证SQL语法合法性（如括号匹配、关键字顺序）。</p><p><strong>生成原始解析树</strong>：结构化表示SQL操作（如SELECT的目标列、WHERE条件）。</p><h2 id="第四步：执行-SQL"><a href="#第四步：执行-SQL" class="headerlink" title="第四步：执行 SQL"></a>第四步：执行 SQL</h2><p>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条SELECT 查询语句流程主要可以分为下面这三个阶段：</p><ul><li>prepare 阶段，也就是预处理阶段；</li><li>optimize 阶段，也就是优化阶段；</li><li>execute 阶段，也就是执行阶段；</li></ul><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>我们先来看看预处理阶段做了什么事情。</p><p><strong>语义解析</strong>：  </p><ol><li><strong>对象存在性检查</strong>：验证表、列、索引是否存在。</li><li><strong>符号解析</strong>：将<code>*</code>扩展为具体列名（如<code>SELECT *</code> → <code>SELECT id, name</code>）。</li><li><strong>视图展开</strong>：替换视图为底层表查询逻辑（如<code>SELECT * FROM view</code> → <code>SELECT * FROM base_table WHERE ...</code>）。</li><li><strong>子查询处理</strong>：将嵌套子查询转换为临时表或JOIN操作。</li></ol><p><strong>预编译语句绑定</strong>：对<code>PREPARE</code>语句的参数进行类型检查和值绑定。</p><p><strong>生成最终解析树</strong>：输出经过语义验证的解析树，然后根据SQL类型将请求路由到对应模块。</p><p><strong>细粒度权限校验</strong>：再次检查用户对<strong>具体表、列</strong>的操作权限（如SELECT <code>users.name</code>权限）。若权限不足，直接返回错误。</p><h3 id="优化器-1"><a href="#优化器-1" class="headerlink" title="优化器"></a>优化器</h3><p>经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。</p><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><p>当然，像<code>select * from product where id = 1</code>的SQL很简单就能看出来，就是选择使用主键索引。</p><p>要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 <code>explain</code> 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引。<br>如果查询语句的执行计划里的 key 为 null 说明没有使用索引，那就会全表扫描（type &#x3D; ALL），这种查询扫描的方式是效率最低档次的：</p><p>product 表的 id 字段是主键索引，若现在新建了一个索引：name 字段为普通索引（二级索引）。假设执行了这条查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">1</span>  <span class="keyword">and</span> name <span class="keyword">like</span> <span class="string">&#x27;i%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。</p><p>很显然这条查询语句是<strong>覆盖索引</strong>，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大，优化器基于查询成本的考虑，会选择查询代价小的普通索引。</p><p>这条语句加个 <code>explain</code> 命令得到执行计划，就可以看到，执行过程中使用了普通索引（name），Exta 为 Using index，这就是表明使用了覆盖索引优化。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。</p><p>接下来，用三种方式执行过程，跟大家说一下执行器和存储引擎的交互过程</p><ul><li>主键索引查询</li><li>全表扫描</li><li>索引下推</li></ul><h4 id="主键索引查询"><a href="#主键索引查询" class="headerlink" title="主键索引查询"></a>主键索引查询</h4><p>以本文开头查询语句为例，看看执行器是怎么工作的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li><li>存储引擎通过主键索引的 B+ 树结构定位到 <code>id = 1</code> 的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li><li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li></ul><p>至此，这个语句就执行完成了。</p><h4 id="全表扫描"><a href="#全表扫描" class="headerlink" title="全表扫描"></a>全表扫描</h4><p>举个全表扫描的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;iphone&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li><li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li><li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</li><li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li></ul><p>至此，这个语句就执行完成了。</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>在这部分非常适合讲索引下推（MySQL 5.6 推出的查询优化策略），这样大家能清楚的知道，「下推」这个动作，下推到了哪里。</p><p>索引下推能够减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p><p>举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了联合索引（age，reward）：</p><p>现在有下面这条查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user  <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">and</span> reward <span class="operator">=</span> <span class="number">100000</span>;</span><br></pre></td></tr></table></figure><p>根据索引规则，联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配，即<strong>范围查询会中断索引的后续匹配</strong>。也就是 <strong>age 字段能用到联合索引，但是 reward 字段则无法利用到索引</strong>。具体原因这里可以看这篇：<a href="https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB">索引常见面试题</a></p><p>那么，不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：</p><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li><li>存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后<strong>进行回表操作</strong>，将完整的记录返回给 Server 层；</li><li>Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；</li><li>接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；</li><li>如此往复，直到存储引擎把表中的所有记录读完。</li></ul><p>可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。</p><p>而使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：</p><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li><li>存储引擎定位到二级索引后，<strong>先不执行回表</strong>操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果<strong>条件不成立</strong>，则直接<strong>跳过该二级索引</strong>。如果<strong>成立</strong>，则<strong>执行回表</strong>操作，将完成记录返回给 Server 层。</li><li>Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。</li><li>如此往复，直到存储引擎把表中的所有记录读完。</li></ul><p>可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足 reward &#x3D; 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。</p><p>当你发现执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推。</p><h1 id="三、SQL更新语句执行流程"><a href="#三、SQL更新语句执行流程" class="headerlink" title="三、SQL更新语句执行流程"></a>三、SQL更新语句执行流程</h1><p>现在看看一条更新语句如何执行的呢？SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_student A <span class="keyword">set</span> A.age<span class="operator">=</span><span class="string">&#x27;19&#x27;</span> <span class="keyword">where</span> A.name<span class="operator">=</span><span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure><p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。（一般记录的是出生日期）</p><p>其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p><ul><li>先查询到张三这一条数据，不会走查询缓存，因为更新语句会导致与该表相关的查询缓存失效。</li><li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li><li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li><li>更新完成。</li></ul><p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p><p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p><p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p><ul><li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？<br>这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p><ul><li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li><li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li></ul><p>这样就解决了数据一致性的问题。</p><h1 id="四、慢SQL解决方案"><a href="#四、慢SQL解决方案" class="headerlink" title="四、慢SQL解决方案"></a>四、慢SQL解决方案</h1><p>MySQL 服务器的资源（CPU、IO、内存等）是有限的，尤其在高并发场景下需要快速处理掉请求，否则一旦出现慢 SQL 就会阻塞掉很多正常的请求，造成大面积的失败&#x2F;超时等。</p><p>一个 SQL 执行的很慢，我们要分两种情况讨论：  </p><ol><li><p>大多数情况下很正常，偶尔很慢，则有如下原因</p><ul><li>数据库在刷新脏页，例如 redo log 写满了需要同步到磁盘。  </li><li>执行的时候，遇到锁，如表锁、行锁。  </li><li>sql写的烂</li></ul></li><li><p>这条 SQL 语句一直执行的很慢，则有如下原因</p><ul><li>没有用上索引或则索引失效：例如该字段没有索引；或则由于对字段进行运算、函数操作导致无法用索引。  </li><li>有索引可能会走全表扫描</li></ul></li></ol><h2 id="SQL执行频率分析"><a href="#SQL执行频率分析" class="headerlink" title="SQL执行频率分析"></a>SQL执行频率分析</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_%&#x27;</span>; <span class="comment">-- 统计所有SQL命令的执行频率（全局范围）</span></span><br></pre></td></tr></table></figure><ul><li>Com_select：执行 select 操作的次数。</li><li>Com_insert：执行 insert 操作的次数，对于批量插入的 insert，只累加一次。</li><li>Com_update：执行 update 操作的次数。</li><li>Com_delete：执行 delete 操作的次数。</li></ul><p>这些参数统计的是<strong>所有存储引擎</strong>（如InnoDB、MyISAM等）的SQL操作总次数，适用于全局负载分析。</p><p>下面这几个参数只是针对 I<strong>nnoDB</strong> 存储引擎的，累加的算法也略有不同，采用行级统计逻辑：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span>; <span class="comment">-- 仅统计InnoDB存储引擎的操作行为</span></span><br></pre></td></tr></table></figure><ul><li>Innodb_rows_deleted：记录通过DELETE操作实际删除的行数总和（如删除100行计数+100）。</li><li>Innodb_rows_inserted：统计通过INSERT操作实际插入的行数总和（如批量插入50行计数+50）。</li><li>Innodb_rows_read：记录SELECT查询返回的行数总和（如查询返回168行计数+168）。</li><li>Innodb_rows_updated：统计通过UPDATE操作实际更新的行数总和（如更新3行计数+3）。</li></ul><p>通过以上几个参数，我们可以快速判断数据库的工作负载类型，以及各种类型的 SQL 大致的<strong>执行比例</strong>是多少。</p><ul><li>读密集型：Com_select 占比超过 80%，需重点关注查询性能（如索引优化、缓存策略）。</li><li>写密集型：Com_insert、Com_update、Com_delete 占比高，需优化写入性能（如批量操作、减少事务粒度）。</li></ul><p>对<strong>事务型</strong>的应用，通过 Com_commit 和 Com_rollback 可以了解事务提交和回滚的情况，<strong>对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题</strong>。</p><h2 id="定位慢查询"><a href="#定位慢查询" class="headerlink" title="定位慢查询"></a>定位慢查询</h2><p>可以通过以下两种方式定位执行效率较低的 SQL 语句（慢查询的统计通常由运维定期统计）：</p><ol><li>对于大量的SQL语句，一句一句分析也不是办法，可以在 MySQL 中开启SQL慢查询日志，如自定义时间为2s，则会开始记录所有超过2s的SQL执行语句。</li><li>慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题时，查询慢查询日志并不能定位问题。这时可以使用 <code>show processlist;</code> 命令查看当前 MySQL 在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li></ol><p><code>show processlist;</code> 命令只列出前 100 条正在运行的线程信息，如果想全列出需要使用 <code>show full processlist;</code>。也可以使用 <code>mysqladmin processlist;</code> 语句得到此信息。</p><p>关于该命令的原文介绍：<br><a href="https://dev.mysql.com/doc/refman/8.4/en/show-processlist.html">https://dev.mysql.com/doc/refman/8.4/en/show-processlist.html</a></p><p>下面为其简单描述：</p><p>除非有 SUPER 权限，可以看到所有线程。否则，只能看到自己的线程（也就是，与您正在使用的 MySQL 账户相关的线程）。</p><p>本语句会报告 TCP&#x2F;IP 连接的主机名称（采用 <em>host_name</em>:<em>client_port</em> 格式），以方便地判定哪个客户端正在做什么。</p><p>如果得到了“too many connections”错误信息，并且想要了解正在发生的情况，本语句是非常有用的。MySQL保留一个额外的连接，让拥有 SUPER 权限的账户使用，以确保管理员能够随时连接和检查系统（假设没有把此权限给予所有的用户）。</p><p>该命令返回内容的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Id       # 线程的唯一标识符，用于识别和管理线程。</span><br><span class="line">User     # 执行线程的用户。</span><br><span class="line">Host     # 发起连接的主机地址。</span><br><span class="line">db       # 当前线程所使用的数据库。</span><br><span class="line">Command  # 连接状态，一般是休眠（sleep），查询（query），连接（connect），初始化（init）</span><br><span class="line">Time     # 线程已经执行的时间（秒）。</span><br><span class="line">State    # 线程的状态，如Locked、Sending data等。</span><br><span class="line">Info     # 执行的SQL语句或命令。</span><br></pre></td></tr></table></figure><p>该命令中最关键的就是 <code>State</code> 列，它提供了线程当前执行状态的描述。<br>例如，<code>Locked</code> 状态表示线程被其他查询锁定，而 <code>Sending data</code> 状态表示正在处理SELECT查询并发送结果给客户端。<br>具体其他状态查询原文：<br><a href="https://dev.mysql.com/doc/refman/8.4/en/replica-io-thread-states.html">https://dev.mysql.com/doc/refman/8.4/en/replica-io-thread-states.html</a></p><h2 id="分析执⾏计划"><a href="#分析执⾏计划" class="headerlink" title="分析执⾏计划"></a>分析执⾏计划</h2><p>使用 <code>EXPLAIN</code> 或 <code>EXPLAIN ANALYZE</code> 分析执行计划；<br>通过查看 <code>type</code>（如 <code>index</code>, <code>range</code>, <code>ALL</code>）、<code>rows</code>（扫描行数）、<code>key</code>（使用的索引）、<code>Extra</code>（如 <code>Using where</code>, <code>Using filesort</code>）等字段，定位性能瓶颈。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">100</span> <span class="keyword">AND</span> status <span class="operator">=</span> <span class="string">&#x27;completed&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果 <code>type=ALL</code>，说明全表扫描，需添加索引；若 <code>key= NULL</code>，说明索引未命中。<br>主要关注这⼏个字段即可：</p><ol><li><code>type</code>：表⽰MySQL在表中找到所需⾏的⽅式，或者叫访问类型<ul><li>type&#x3D;ALL，全表扫描，MySQL遍历全表来找到匹配⾏</li><li>type&#x3D;index，索引全扫描</li><li>type&#x3D;range，索引范围扫描</li><li>type&#x3D;eq_ref，唯⼀索引</li><li>type&#x3D;NULL，MySQL不⽤访问表或者索引，直接就能够得到结果</li></ul></li><li><code>possible_keys</code>: 表⽰查询可能使⽤的索引</li><li><code>key</code>: 实际使⽤的索引，若 <code>key= NULL</code>，说明索引未命中。</li><li><code>key_len</code>: 使⽤索引字段的⻓度</li><li><code>rows</code>: 扫描⾏的数量</li><li><code>Extra</code>：<ul><li>using index：覆盖索引，不回表</li><li>using where：回表查询</li><li>using filesort：需要额外的排序，不能通过索引得到排序结果</li></ul></li></ol><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>sql优化当中，有⼀个⾮常重要的内容就是：索引优化。<br>很多时候sql语句，⾛了索引，和没有⾛索引，执⾏效率差别很⼤。所以索引优化被作为sql优化的首选。索引优化的第⼀步是：检查sql语句有没有⾛索引。</p><p>那么，如何查看sql⾛了索引没？<br>可以使⽤ <code>explain</code> 命令，查看 MySQL 的执⾏计划，重点关注 <code>type</code>, <code>key</code> 字段值（回看上部分）</p><p> <strong>原则</strong>：</p><ul><li>为 <code>WHERE</code>, <code>JOIN</code>, <code>ORDER BY</code> 中的高频字段创建索引。  </li><li><strong>最左前缀原则</strong>：复合索引 <code>(a, b, c)</code> 可以支持 <code>a</code> 或 <code>(a,b)</code> 的查询，但无法支持 <code>(b,c)</code>。  </li><li><strong>覆盖索引</strong>：索引本身包含查询所需的所有字段，避免回表。</li></ul><p><strong>索引失效场景</strong>：</p><ul><li>在索引列上使用函数或计算（如 <code>WHERE YEAR(create_time) = 2023</code> → 应改为 <code>WHERE create_time BETWEEN &#39;2023-01-01&#39; AND &#39;2023-12-31&#39;</code>）。  </li><li><code>OR</code> 条件导致索引失效（如 <code>WHERE a=1 OR b=2</code> → 拆分为 <code>UNION ALL</code>）。</li></ul><p><strong>案例</strong>：</p><ul><li><strong>问题</strong>：<code>SELECT * FROM user WHERE mobile = &#39;13812345678&#39;</code>，<code>mobile</code> 是 <code>VARCHAR</code> 类型，但查询时条件传入数字 <code>13812345678</code>，导致隐式转换索引失效（所有记录的 mobile 字段值都要经历一次类型转换）。  </li><li><strong>优化</strong>：确保参数类型与字段一致，或在查询时强制类型：<code>WHERE mobile = &#39;13812345678&#39;</code>。</li></ul><h2 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h2><h3 id="避免使⽤select"><a href="#避免使⽤select" class="headerlink" title="避免使⽤select *"></a>避免使⽤<code>select *</code></h3><p>sql 语句查询时，只查需要⽤到的列，多余的列根本⽆需查出来。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>在实际业务场景中，可能我们真正需要使⽤的只有其中⼀两列。查了很多数据，但是不⽤，⽩⽩浪费了数据库资源，⽐如：内存或者cpu。</li><li>此外，多查出来的数据，通过⽹络IO传输的过程中，也会增加数据传输的时间。</li><li>还有⼀个最重要的问题是：<code>select *</code> 不会⾛覆盖索引，会出现⼤量的回表操作，⽽从导致查询sql的性能很低。</li></ul><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name,age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="⽤union-all代替union"><a href="#⽤union-all代替union" class="headerlink" title="⽤union all代替union"></a>⽤<code>union all</code>代替<code>union</code></h3><p><code>union</code> 和 <code>union all</code> 的差异主要是前者需要将结果集合并后再进⾏唯⼀性过滤操作，这就会涉及到排序，增加⼤量的CPU运算，加⼤资源消耗及延迟。<br>⽽如果使⽤ <code>union all</code> 关键字，可以获取所有数据，包含重复的数据。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>排重的过程需要遍历、排序和⽐较，它更耗时，更消耗cpu资源。<br>所以如果能⽤ <code>union all</code> 的时候，尽量不⽤ <code>union</code>。</p><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>)</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>除⾮是有些特殊的场景，⽐如 <code>union all</code> 之后，结果集中出现了重复数据，⽽业务场景中<br>是不允许产⽣重复数据的，这时可以使⽤ <code>union</code>。</p><h3 id="⼩表驱动⼤表，区分in和exists"><a href="#⼩表驱动⼤表，区分in和exists" class="headerlink" title="⼩表驱动⼤表，区分in和exists"></a>⼩表驱动⼤表，区分<code>in</code>和<code>exists</code></h3><p>⼩表驱动⼤表，也就是说⽤⼩表的数据集驱动⼤表的数据集。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表A <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> 表B)</span><br></pre></td></tr></table></figure><p>上⾯的语句相当于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表A <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表B <span class="keyword">where</span> 表B.id<span class="operator">=</span>表A.id)</span><br></pre></td></tr></table></figure><p>区分 <code>in</code> 和 <code>exists</code> 主要是造成了驱动顺序的改变（这是性能变化的关键）</p><p>如果 SQL 语句中包含了 <code>in</code> 关键字，则它会优先执⾏ <code>in</code> ⾥⾯的⼦查询语句，然后再执⾏ <code>in</code> 外⾯的语句。如果 <code>in</code> ⾥⾯的数据量很少，作为条件查询速度更快。<br>⽽如果 SQL 语句中包含了 <code>exists</code> 关键字，它优先执⾏ <code>exists</code> 左边的语句（即主查询语句）。然后把它作为条件，去跟右边的语句匹配。如果匹配上，则可以查询出数据。如果匹配不上，数据就被过滤掉了。</p><p>总结⼀下：</p><ul><li>in 适⽤于左边⼤表，右边⼩表。</li><li>exists 适⽤于左边⼩表，右边⼤表。</li></ul><h3 id="用连接查询代替子查询"><a href="#用连接查询代替子查询" class="headerlink" title="用连接查询代替子查询"></a>用连接查询代替子查询</h3><p>MySQL 中如果需要从两张以上的表中查询出数据的话，一般有两种实现方式：子查询和连接查询。</p><p>子查询语句可以通过<code>in</code>关键字实现，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表A <span class="keyword">where</span> id <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> id <span class="keyword">from</span> 表B <span class="keyword">where</span> status<span class="operator">=</span><span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>但是对于数据库来说，在绝⼤部分情况下，连接会⽐⼦查询更快，使⽤连接的⽅式，MySQL 优化器⼀般可以⽣成更佳的执⾏计划，更⾼效地处理查询。</p><p>⽽⼦查询往往需要运⾏重复的查询，⼦查询⽣成的临时表上也没有索引， 因此效率会更低。所以建议使用连接查询替代：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 表A.<span class="operator">*</span> <span class="keyword">from</span> 表A</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> 表B <span class="keyword">on</span> 表A.id <span class="operator">=</span> 表B.id</span><br><span class="line"><span class="keyword">where</span> 表B.status<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><p>如果你有⼀批数据经过业务处理之后，需要插⼊数据，该怎么办？</p><p>反例：<br>在循环中逐条插⼊数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Order order: list)&#123;</span><br><span class="line">orderMapper.insert(order):</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该操作需要多次请求数据库，才能完成这批数据的插⼊。<br>但众所周知，我们在代码中，每次远程请求数据库，是会消耗⼀定性能的。⽽如果我们的代码需要请求多次数据库，才能完成本次业务功能，势必会消耗更多的性能。</p><p>正例：<br>提供⼀个批量插⼊数据的⽅法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderMapper.insertBatch(list):</span><br></pre></td></tr></table></figure><p>这样只需要远程请求⼀次数据库，sql 性能会得到提升，数据量越多，提升越⼤。<br>但需要注意的是，不建议⼀次批量操作太多的数据，如果数据太多数据库响应也会很慢。批量操作需要把握⼀个度，建议每批数据尽量控制在 500 以内。如果数据多于 500，则分多批次处理。</p><h3 id="当只要一行数据时使用-LIMIT-1"><a href="#当只要一行数据时使用-LIMIT-1" class="headerlink" title="当只要一行数据时使用 LIMIT 1"></a>当只要一行数据时使用 <code>LIMIT 1</code></h3><p>针对非主键的其他查询，加上 <code>LIMIT 1</code> 可以增加性能。这样 MySQL 数据库引擎会在找到一条数据后停止搜索，而不是继续往后查下一条符合记录的数据（否则即使已经查到一条结果，也会继续查询是否还存在等值结果，再返回结果）。</p><p>例如：<br>有时候，我们需要查询某些数据中的第⼀条，⽐如：查询某个⽤⼾下的第⼀个订单，想看看他第⼀次的首单时间。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, create_date <span class="keyword">from</span> 表A</span><br><span class="line"><span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">123</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> create_date <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><p>根据⽤⼾ id 查询订单，按下单时间排序，先查出该⽤⼾所有的订单数据，得到⼀个订单集合。然后在代码中，获取第⼀个元素的数据，即首单的数据，就能获取首单时间。虽说这种做法在功能上没有问题，但它的效率⾮常不⾼，需要先查询出所有的数据，有点浪费资源。</p><p>正例：<br>使⽤ <code>limit 1</code>，只返回该⽤⼾下单时间最⼩的那⼀条数据即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, create_date <span class="keyword">from</span> 表A</span><br><span class="line"><span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">123</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> create_date <span class="keyword">asc</span></span><br><span class="line">limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="调整where子句中的连接顺序"><a href="#调整where子句中的连接顺序" class="headerlink" title="调整where子句中的连接顺序"></a>调整<code>where</code>子句中的连接顺序</h3><p>MySQL 采用从左往右的顺序解析 <code>where</code> 子句，可以将过滤数据多的条件放在前面，最快速度缩小结果集。</p><p>例子：查询用户表中北京地区且年龄大于 30 岁的用户。<br>优化前：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 若 age 无索引，city 有索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users </span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">30</span>          <span class="comment">-- 先执行：全表扫描过滤 age &gt; 30</span></span><br><span class="line"><span class="keyword">and</span> city <span class="operator">=</span> <span class="string">&#x27;北京&#x27;</span>;     <span class="comment">-- 后执行：再通过索引过滤 city</span></span><br></pre></td></tr></table></figure><p>问题：若 <code>age &gt; 30</code> 过滤性差（例如 80% 用户年龄 &gt;30），会先扫描大量数据，再通过索引过滤。</p><p>优化后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users </span><br><span class="line"><span class="keyword">where</span> city <span class="operator">=</span> <span class="string">&#x27;北京&#x27;</span>      <span class="comment">-- 先执行：通过索引快速过滤 city</span></span><br><span class="line"><span class="keyword">and</span> age <span class="operator">&gt;</span> <span class="number">30</span>;         <span class="comment">-- 后执行：仅对少量数据检查 age</span></span><br></pre></td></tr></table></figure><p>优先利用 <code>city</code> 索引快速缩小数据集，再检查 <code>age</code> 条件，减少计算量。</p><p>最后可以再通过 <code>EXPLAIN</code> 分析执行计划，验证优化效果。</p><h3 id="不要使用ORDER-BY-RAND"><a href="#不要使用ORDER-BY-RAND" class="headerlink" title="不要使用ORDER BY RAND()"></a>不要使用<code>ORDER BY RAND()</code></h3><p>想打乱返回的数据行？随机挑一个数据？但你却不了解这样做有多么可怕的性能问题。</p><p>如果你真的想把返回的数据行打乱了，你有 N 种方法可以达到这个目的。而这样使用只让你的数据库的性能呈指数级的下降。这里的问题是：MySQL会不得不去执行 RAND() 函数（很耗 CPU），而且这是为每一行记录去记行（扫全表），然后再对其排序，就算是用了 <code>limit 1</code> 也无济于事（因为要排序）。</p><h3 id="优化GROUP-BY"><a href="#优化GROUP-BY" class="headerlink" title="优化GROUP BY"></a>优化<code>GROUP BY</code></h3><p><code>GROUP BY</code> 关键字，它主要的功能是去重和分组。</p><p><strong>从排序优化</strong><br>当使用 <code>GROUP BY</code> 分组时，MySQL 默认会按分组字段的升序对结果进行排序（即使没有显式使用 <code>ORDER BY</code>）。这种排序操作会触发 <code>Using filesort</code>（文件排序），尤其是在分组字段未使用索引时，可能会显著增加查询时间。并且尽量让 <code>group by</code> 过程⽤上表的索引。<br>确认⽅法是 <code>explain</code> 结果⾥没有 <code>Using temporary</code> 和 <code>Using filesort</code>。</p><p>如果业务逻辑不需要结果有序（例如仅需要统计结果），禁用排序可以提升性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> … <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">NULL</span>;  <span class="comment">-- 禁止排序</span></span><br></pre></td></tr></table></figure><hr><p><strong>从条件优化</strong><br>通常它会跟<code>having</code>一起配合使用，表示分组后再根据一定的条件过滤数据。</p><p>反例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,user_name <span class="keyword">from</span> <span class="keyword">order</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id,user_name</span><br><span class="line"><span class="keyword">having</span> user_id <span class="operator">&lt;=</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>这种写法性能不好，它先把所有的订单根据用户id分组之后，再去过滤用户id大于等于200的用户。分组是一个相对耗时的操作，为什么我们不先缩小数据的范围之后，再分组呢？</p><p>正例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id,user_name <span class="keyword">from</span> <span class="keyword">order</span></span><br><span class="line"><span class="keyword">where</span> user_id <span class="operator">&lt;=</span> <span class="number">200</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_id,user_name</span><br></pre></td></tr></table></figure><p>使用where条件在分组前，就把多余的数据过滤掉了，这样分组时效率就会更高一些。</p><blockquote><p>其实这是一种思路，不仅限于group by的优化。我们的sql语句在做一些耗时的操作之前，应尽可能缩小数据范围，这样能提升sql整体的性能。</p></blockquote><h3 id="JOIN查询"><a href="#JOIN查询" class="headerlink" title="JOIN查询"></a><code>JOIN</code>查询</h3><p>我们在涉及到多张表联合查询的时候，一般会使用<code>join</code>关键字。</p><p><strong>索引优化</strong><br>如果你的应用程序有很多 <code>JOIN</code> 查询，你应该确认两个表中 <code>JOIN</code> 的字段是被建过<strong>索引</strong>的。这样，MySQL 内部会启动为你优化 <code>JOIN</code> 语句的机制。</p><p>而且，这些被用来 <code>JOIN</code> 的字段，应是<strong>相同类型</strong>的。例如：如果你要把 <code>DECIMAL</code> 字段和一个 <code>INT</code> 字段 <code>JOIN</code> 在一起，MySQL 就无法使用它们的索引。对于 <code>STRING</code> 类型，还需要有<strong>相同的字符集</strong>才行（两个表的字符集有可能不一样）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> company_name <span class="keyword">from</span> users</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> companies <span class="keyword">on</span> users.state <span class="operator">=</span> companies.state</span><br><span class="line"><span class="keyword">where</span> users.id <span class="operator">=</span> ...</span><br></pre></td></tr></table></figure><p>例如以上两个 state 字段应该是被建过索引的，而且应是相当类型、相同字符集的。</p><hr><p><strong>小表驱动大表</strong><br>而 <code>join</code> 使用最多的是 <code>left join</code> 和 <code>inner join</code>。</p><ul><li><code>left join</code>：求两个表的交集外加左表剩下的数据。</li><li><code>inner join</code>：求两个表交集的数据。</li></ul><p><code>join</code> 用法亦存在小表驱动大表的思想；如果两张表使用 <code>left join</code> 关联，MySQL 会默认用 <code>left join</code> 关键字左边的表，去驱动它右边的表。如果左边的表数据很多时，就会出现性能问题。</p><p>假设有两张表，<code>users</code>（用户表，大表）存在1000 万条数据。<code>orders</code>（订单表，小表）存在100 万条数据。现在需要查询所有用户及其订单信息（包含无订单的用户）。</p><p>低效写法（大表驱动小表）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 left join，左表 users 是大表</span></span><br><span class="line"><span class="keyword">select</span> u.id, u.name, o.order_id, o.amount</span><br><span class="line"><span class="keyword">from</span> users u</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> orders o <span class="keyword">on</span> u.id <span class="operator">=</span> o.user_id</span><br><span class="line"><span class="keyword">where</span> u.country <span class="operator">=</span> <span class="string">&#x27;cn&#x27;</span>;  <span class="comment">-- 假设查询中国用户</span></span><br></pre></td></tr></table></figure><p><code>left join</code> 强制以左表 <code>users</code> 作为驱动表，需遍历 1000 万行。即使 <code>orders.user_id</code> 有索引，仍需对 1000 万行的 <code>users</code> 逐行查找右表。</p><p>优化方案：使用 <code>inner join</code><br>如果两张表使用 <code>inner join</code> 关联，MySQL 会自动选择两张表中的小表，去驱动大表，所以性能上不会有太大的问题。（自动小表驱动大表）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 仅查询有订单的中国用户（inner join）</span></span><br><span class="line"><span class="keyword">select</span> u.id, u.name, o.order_id, o.amount</span><br><span class="line"><span class="keyword">from</span> orders o                  <span class="comment">-- 小表作为驱动表</span></span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> users u <span class="keyword">on</span> o.user_id <span class="operator">=</span> u.id</span><br><span class="line"><span class="keyword">where</span> u.country <span class="operator">=</span> <span class="string">&#x27;cn&#x27;</span>;</span><br></pre></td></tr></table></figure><p>总结：<br>在用 <code>left join</code> 关联查询时，左边要用小表，右边可以用大表。如果能用 <code>inner join</code> 的地方，尽量少用 &#96;left join。</p><h3 id="高效的分页"><a href="#高效的分页" class="headerlink" title="高效的分页"></a>高效的分页</h3><p>有时候，列表页在查询数据时，为了避免一次性返回过多的数据影响接口性能，我们一般会对查询接口做分页处理。</p><p>在mysql中分页一般用的<code>limit</code>关键字：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,age <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">10</span>,<span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>如果表中数据量少，用limit关键字做分页，没啥问题。但如果表中数据量很多，用它就会出现性能问题。</p><p>比如现在分页参数变成了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,age <span class="keyword">from</span> <span class="keyword">user</span> limit <span class="number">1000000</span>, <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>mysql 会查到 1000020 条数据，然后丢弃前面的 1000000 条，只查后面的 20 条数据，这个是非常浪费资源的。那么，这种海量数据该怎么分页呢？</p><p>优化后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">1000000</span> limit <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>先找到上次分页最大的id，然后利用id上的索引查询。不过该方案，要求id是连续的，并且有序的。</p><p>还能使用<code>between</code>优化分页。但需要注意的是 <code>between</code> 要在唯一索引上分页，不然会出现每页大小不一致的问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">1000000</span> <span class="keyword">and</span> <span class="number">1000020</span>;</span><br></pre></td></tr></table></figure><h3 id="避免函数运算导致索引失效"><a href="#避免函数运算导致索引失效" class="headerlink" title="避免函数运算导致索引失效"></a>避免函数运算导致索引失效</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">year</span>(d) <span class="operator">&gt;=</span> <span class="number">2016</span>;</span><br></pre></td></tr></table></figure><p>即使 d 字段有索引，也会全盘扫描，因为在 <code>year(d) &gt;= 2016</code> 中，<code>year(d)</code> 是对字段 d 的函数运算。数据库无法直接使用 d 的索引，因为索引存储的是原始值（如日期 2023-01-01），而非运算后的结果（如 2023）。应该优化为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> d <span class="operator">&gt;=</span> <span class="string">&#x27;2016-01-01&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="使用IN替换OR"><a href="#使用IN替换OR" class="headerlink" title="使用IN替换OR"></a>使用<code>IN</code>替换<code>OR</code></h3><p>低效查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> LOC_ID <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> LOC_ID <span class="operator">=</span> <span class="number">20</span> <span class="keyword">or</span> LOC_ID <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>若 LOC_ID 上有非聚簇索引，数据库需要为每个 <code>or</code> 条件单独执行一次索引查询。即分别以 10, 20, 30 为条件查询了三次</p><p>⾼效查询</p><p>而使⽤ <code>in</code> 之后只⾛⼀次。MySQL对于 <code>in</code> 做了相应的优化，即将 <code>in</code> 中的常量全部存储在⼀个数组⾥⾯，⽽且这个数组是排好序的，通过一次索引扫描完成所有条件的匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> LOC_IN <span class="keyword">in</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>但是如果数值较多，产⽣的消耗也是⽐较⼤的。再例如：<code>in(1, 2, 3)</code> 对于连续的数值，能⽤ <code>between</code> 就不要⽤ <code>in</code> 了；再或者使⽤连接来替换。</p><h3 id="LIKE使用右模糊"><a href="#LIKE使用右模糊" class="headerlink" title="LIKE使用右模糊"></a><code>LIKE</code>使用右模糊</h3><p><code>LIKE</code>双百分号⽆法使⽤到索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%de%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>应优化为右模糊</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;de%&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="表结构优化"><a href="#表结构优化" class="headerlink" title="表结构优化"></a>表结构优化</h2><ol><li><p><strong>永远为每张表创建主键</strong><br> 我们应该为数据库⾥的每张表都设置⼀个 id 作为主键，最好还是 <code>INT</code> 类型的（推荐使⽤  <code>UNSIGNED</code> 即⽆符号化），并设置上⾃动增加的 <code>AUTO_INCREMENT</code> 标志。</p><ul><li>表数据的存储在磁盘中是按照主键顺序存放的，所以使⽤主键查询数据速度最快。</li><li><code>INT</code> 类型相⽐字符串类型，其⻓度更为固定，查询效率更⾼。</li><li>还有⼀些操作需要⽤到主键，⽐如集群、分区等。在这些情况下，主键的性能和设置变得⾮常重要。</li></ul><p> 所以建表时⼀定要带有主键，后续优化效果最好。</p></li><li><p><strong>固定⻓度的表会更快</strong><br> 如果表中的所有字段都是“固定⻓度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： <code>VARCHAR</code>、<code>TEXT</code>、<code>BLOB</code>。只要你包括了其中⼀个这些字段，那么这个表就不是“固定⻓度静态表”了，这样，MySQL 引擎会⽤另⼀种⽅法来处理。</p><p> 固定⻓度的表会提⾼性能，因为 MySQL 搜寻得会更快⼀些，因为这些固定的⻓度是很容易计算下⼀个数据的偏移量，所以读取的⾃然也会很快。⽽如果字段不是定⻓的，那么，每⼀次要找下⼀条的话，需要程序找到主键。</p><p> 并且，固定⻓度的表也更容易被缓存和重建。不过，唯⼀的副作⽤是，固定⻓度的字段会浪费⼀些空间，因为定⻓的字段⽆论你⽤不⽤，他都是要分配那么多的空间。</p></li><li><p><strong>通过拆分表结构，提⾼访问效率</strong><br> 把数据库中的表按列变成⼏张表的⽅法，这样可以降低表的复杂度和字段的数⽬，从⽽达到优化的⽬的。</p></li><li><p><strong>越⼩的列会越快</strong><br> 对于⼤多数的数据库引擎来说，硬盘操作可能是最重⼤的瓶颈。所以，把你的数据变得紧凑会对这种情况⾮常有帮助，因为这减少了对硬盘的访问。<br> 如果⼀个表只会有⼏列罢了（⽐如说字典表、配置表），那么，我们就没有理由使⽤ <code>INT</code> 来做主键，使⽤ <code>MEDIUMINT</code>、<code>SMALLINT</code> 或是更⼩的 <code>TINYINT</code> 会更经济⼀些。如果你不需要记录时间，使⽤ <code>DATE</code> 要⽐ <code>DATETIME</code> 好得多。</p></li><li><p><strong>字段类型</strong><br> 用 <code>INT</code> 替代 <code>VARCHAR</code> 存储性别、状态等枚举值；用 <code>DATETIME</code> 替代 <code>VARCHAR</code> 存储时间。</p></li><li><p><strong>范式与反范式</strong><br> 高频查询的关联字段可冗余存储（如订单表中冗余用户名称），减少 <code>JOIN</code> 次数。  </p></li><li><p><strong>分区与分表</strong>：  </p><ul><li>对大表按时间或范围分区（如按 <code>create_time</code> 分区），加速范围查询。  </li><li>通过水平分表（如按用户ID哈希）解决单表数据量过大问题。</li></ul></li></ol><h2 id="MySQL服务端参数优化"><a href="#MySQL服务端参数优化" class="headerlink" title="MySQL服务端参数优化"></a>MySQL服务端参数优化</h2><p><strong>Innodb_buffer_pool_size</strong><br>影响性能的最主要参数，⼀般建议配置为系统总内存的 70-80%，这个参数决定了服务可分配的最⼤内存。</p><p><strong>Innodb_log_buffer_size</strong><br>顾名思义，这个参数就是⽤来设置 Innodb 的 Log Buffer ⼤⼩的，系统默认值为 1MB 。<br>Log Buffer 的主要作⽤就是缓冲 Log 数据，提⾼写 Log 的 I&#x2F;O 性能。<br>⼀般来说，如果你的系统不是写负载⾮常⾼且以⼤事务居多的话， 8MB 以内的⼤⼩就完全⾜够了。</p><p><strong>连接数</strong><br>当数据库连接池被占满时，如果有新的 SQL 语句要执行，只能排队等待，等待连接池中的连接被释放（等待之前的 SQL 语句执行完成）。</p><p>如果监控发现数据库连接池的使用率过高，甚至是经常出现排队的情况，则需要进行调优。</p><p><em>查看&#x2F;设置最大连接数</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看最大连接数</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%max_connection%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> extra_max_connections <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> max_connections       <span class="operator">|</span> <span class="number">2512</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重新设置最大连接数</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> max_connections<span class="operator">=</span><span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>在 &#x2F;etc&#x2F;my.cnf 里面设置数据库的最大连接数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">max_connections = 1000</span><br></pre></td></tr></table></figure><p><em>查看当前连接数</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span>  <span class="string">&#x27;Threads%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name     <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Threads_cached    <span class="operator">|</span> <span class="number">32</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Threads_connected <span class="operator">|</span> <span class="number">10</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Threads_created   <span class="operator">|</span> <span class="number">50</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Threads_rejected  <span class="operator">|</span> <span class="number">0</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Threads_running   <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>Threads_connected：表示当前连接数。跟 show processlist 结果相同。准确的来说，Threads_running 代表的是当前并发数。</li><li>Threads_running：表示激活的连接数。一般远低于 connected 数值。</li><li>Threads_created：表示创建过的线程数。</li></ul><p>如果我们在 MySQL 服务器配置文件中设置了 thread_cache_size，那么当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁（前提是缓存数未达上限）。<br>如果发现 Threads_created 值过大的话，表明 MySQL 服务器一直在创建线程，这也是比较耗资源，因此可以适当增加配置文件中 thread_cache_size 值。</p><p><strong>thread_cache_size</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;thread_cache_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> thread_cache_size <span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github Pages+Github Action</title>
      <link href="/6178418ef979/"/>
      <url>/6178418ef979/</url>
      
        <content type="html"><![CDATA[<p>本博客是使用<a href="https://hexo.io/zh-cn/">Hexo博客框架</a>+利用Github Pages建立的一个静态站点</p><p>唯一的缺点是Hexo编译代码后，基本不能对编译后的文件进行更改，添加新的文章也需要使用Hexo对其重新编译；所以只能在设备部署Hexo, NodeJS之类后才能给新添加的东西进行编译。</p><p>解决办法就是利用Github Action之类的进行CICD。这样无需部署任何服务，只要仓库收到了新的提交，即可自动完成上述的一系列操作。（前提是文件、位置啥的符合Hexo规范）</p><p>首先了解一下什么是Github Pages和Action吧：<br><a href="https://docs.github.com/zh/pages/getting-started-with-github-pages">GitHub Pages 使用入门</a><br><a href="https://docs.github.com/zh/actions/writing-workflows/quickstart">GitHub Actions 快速入门</a></p><p>使用也很简单，跟其他CICD区别不大。</p><p>步骤：</p><ol><li>先给Hexo创建一个本地仓库和远程仓库</li><li>在Hexo项目根目录创建<code>.github/workflows/deploy.yml</code>文件，并填写工作流</li><li>回到Hexo的配置文件<code>_config.yml</code>，<code>deploy: branch</code>参数改成<code>gh-pages</code></li><li>到Github个人设置的开发者设置处添加一个密钥，必须拥有<code>repo</code>和<code>workflow</code>权限</li><li>到Hexo的Github远程仓库<code>Setting-&gt;Security-&gt;Actions secrets and variables-&gt;action</code>添加上面生成的密钥，名字写成<code>GH_TOKEN</code></li><li>给这个远程仓库创建一个<code>gh-pages</code>分支，在远程仓库<code>Setting-&gt;Pages</code>处，选择刚才创建的分支作为静态页面的文件源</li><li>本地推送后，等待action完成即可访问静态页面（<code>userName.github.io/[repo]</code>）</li></ol><blockquote><p>工作流示例：<a href="https://github.com/ECAMT35/ecamt35.github.io/blob/master/.github/workflows/deploy.yml">Github Action’s workflow</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch+Labwc 使用</title>
      <link href="/ce269dce74a9/"/>
      <url>/ce269dce74a9/</url>
      
        <content type="html"><![CDATA[<p>Archlinux + Labwc WM (Wayland)</p><p>My dotfiles : <a href="https://github.com/ECAMT35/dotfiles.git">https://github.com/ECAMT35/dotfiles.git</a></p><h1 id="Arch"><a href="#Arch" class="headerlink" title="Arch"></a>Arch</h1><p>主文件系统：ext4<br>分区：&#x2F;boot&#x3D;1G, &#x2F;&#x3D;128G, SWAP&#x3D;32G, &#x2F;home&#x3D;remaining, total&#x3D;1T<br>boot：GRUB</p><p>命令解释器: bash<br>文本编辑器: neovim<br>网络: NetworkManager<br>硬盘检测: smartmontools<br>监控: htop<br>笔记本电源管理: TLP</p><h1 id="labwc"><a href="#labwc" class="headerlink" title="labwc"></a>labwc</h1><p>官方文档：<a href="https://labwc.github.io/integration.html">labwc</a></p><h2 id="桌面环境软件包"><a href="#桌面环境软件包" class="headerlink" title="桌面环境软件包"></a>桌面环境软件包</h2><p>字体:<br>noto-fonts<br>noto-fonts-cjk<br>ttf-nerd-fonts-symbols<br>ttf-nerd-fonts-symbols-common</p><p>屏幕管理:<br>锁屏: swaylock + swayidle<br>关闭屏幕: wlopm + swayidle<br>屏幕分辨率: <a href="https://sr.ht/~emersion/wlr-randr/">wlr-randr</a><br>背光调节: brightnessctl<br>桌面壁纸: <a href="https://github.com/swaywm/swaybg">swaybg</a><br>bar: waybar</p><p>终端模拟器: foot<br>输入法: fcitx5<br>启动器: <a href="https://man.archlinux.org/man/wofi.1.en">wofi</a><br>剪切板: wofi + wl-clipboard + <a href="https://github.com/sentriz/cliphist">cliphist</a><br>截图: <a href="https://sr.ht/~emersion/grim/">grim</a> + slurp + swappy<br>终端文件管理: yazi<br>浏览器: firefox<br>文件下载: aria2c, <a href="https://github.com/P3TERX/aria2.conf">aria2c config</a><br><del>消息提醒: dunst</del><br>安卓模拟器: waydroid</p><p>音视频媒体:<br>声音设置: alsa + pipewire + wireplumber<br>图片查看器: swayimg<br>视频播放器: mpv<br>视频录制: OBS<br>XDG 桌面门户: xdg-desktop-portal-gtk, xdg-desktop-portal-wlr</p><p>游戏: wine, steam, <del>KVM</del></p><p>文档编辑: LibreOffice, obsiadian<br>画板、图片编辑: krita<br>小沙箱: flatpak</p><hr><p>其他wayland应用查看<br><a href="https://arewewaylandyet.com/">https://arewewaylandyet.com/</a></p><h1 id="优化部分"><a href="#优化部分" class="headerlink" title="优化部分"></a>优化部分</h1><h2 id="ext4挂载选项"><a href="#ext4挂载选项" class="headerlink" title="ext4挂载选项"></a>ext4挂载选项</h2><ul><li>noatime</li><li>commit&#x3D;180</li><li>开启 fast_commit</li></ul><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><ul><li>开启 Periodic TRIM</li></ul><h2 id="禁用看门狗"><a href="#禁用看门狗" class="headerlink" title="禁用看门狗"></a>禁用看门狗</h2><ul><li>禁用看门狗</li></ul><h2 id="视频硬件加速"><a href="#视频硬件加速" class="headerlink" title="视频硬件加速"></a>视频硬件加速</h2><p>相关驱动(部分已经合并到mesa)：<br><a href="https://wiki.archlinux.org/title/Hardware_video_acceleration">https://wiki.archlinux.org/title/Hardware_video_acceleration</a></p><p>firefox进<code>about:config</code>设置：<br><a href="https://wiki.archlinux.org/title/Firefox#Hardware_video_acceleration">https://wiki.archlinux.org/title/Firefox#Hardware_video_acceleration</a></p><ul><li>media.ffmpeg.vaapi.enabled&#x3D;true</li><li>media.hardware-video-decoding.force-enabled&#x3D;true</li></ul><h2 id="firefox"><a href="#firefox" class="headerlink" title="firefox"></a>firefox</h2><p>关闭磁盘缓存：</p><ul><li>browser.cache.disk.enable&#x3D;false</li><li>browser.cache.memory.enable&#x3D;true</li></ul><p>其他可选调整：<br><a href="https://wiki.archlinux.org/title/Firefox/Tweaks">https://wiki.archlinux.org/title/Firefox/Tweaks</a><br><a href="https://github.com/arkenfox/user.js/">https://github.com/arkenfox/user.js/</a></p>]]></content>
      
      
      <categories>
          
          <category> GNU/Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Archlinux </tag>
            
            <tag> Labwc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>置顶</title>
      <link href="/78fcc30b2e20/"/>
      <url>/78fcc30b2e20/</url>
      
        <content type="html"><![CDATA[<p>我不时会思考这样的事情。</p><p>世界的界限在哪里呢……</p><p>世界的……世界的尽头的再尽头……</p><p>如果有那种地方……</p><p>如果我能站在那种地方……我还能不能跟平时一样眺望那尽头的风景呢？？会怎样呢……</p><p>把这当做理所当然……觉得有点奇怪吧？</p><p>因为那里是世界的尽头啊。</p><p>是世界的界限哦。</p><p>如果我能看得到……那世界的界限……不就与“我的界限”是同义的了？</p><p>因为，我在那个地方所看到的世界……不就是我一直见到的……我的世界吗。</p><p>也就是说，世界的界限……即是我的界限。</p><p>世界是我所看到的、触摸到的、以及感受到的。</p><p>那么，世界到底是什么呢。</p><p>我会想，世界跟我区别是什么呢……</p><p>有吗？</p><p>世界跟我的差别。</p><p>所以我说道。</p><p>我跟世界没有什么差别……</p><p>我如此坚信着。</p><p>正因如此，我抱有疑问。</p><p>包含了他人的世界是什么？</p><p>如果世界就是我，那其它的人是什么？</p><p>他们也拥有世界吗？</p><p>如果有，那些是互相独立、互不相交的世界吗？</p><p>还是说这些世界能够相交呢？</p><p>所有的世界……所有的灵魂……能看到同样的一个世界吗？</p><p>我所看到的、世界尽头的风景。</p><p>世界的风景。</p><p>最尽头的风景。</p><p>在那个时候，你也同样地在看着世界的尽头吧。</p><p>你所看到的世界尽头的天空。</p><p>世界之界限的天空。</p><p>最尽头的天空。</p><p>我能不能够和你一起看呢？</p><p>在那里看着同一个世界的终结……</p><p>虽然不在同一片天空之下……却在同一片天空之下看着……</p><p>……我不时会思考这样的事情。</p><p>在回忆起……</p><p>回忆起那片向日葵前方的坡道时。</p><p>——— <em>《Wonderful Everyday Down the Rabbit-Hole》</em></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>系统维护日志</title>
      <link href="/1ab51985d1ca/"/>
      <url>/1ab51985d1ca/</url>
      
        <content type="html"><![CDATA[<h1 id="Fontconfig"><a href="#Fontconfig" class="headerlink" title="Fontconfig"></a>Fontconfig</h1><p>参考资料：<br><a href="https://wiki.archlinux.org/title/Font_configuration">Font configuration</a></p><p><a href="https://www.freedesktop.org/wiki/Software/fontconfig/">Fontconfig</a> 是一个用于向应用程序提供可用的<a href="https://wiki.archlinuxcn.org/wiki/%E5%AD%97%E4%BD%93" title="字体">字体</a>列表，以及字体渲染配置的库。</p><p>Fontconfig 的默认字体路径是 <code>/usr/share/fonts/</code> 和 <code>~/.local/share/fonts</code>（以及过时的 <code>~/.fonts/</code>）。Fontconfig 将在这些路径下递归查找字体。</p><p>用户配置文件位于 <code>$XDG_CONFIG_HOME/fontconfig/fonts.conf</code> 中（通常是 <code>$HOME/.config/fontconfig/fonts.conf</code>）。全局配置文件位于 <code>/etc/fonts/local.conf</code>。 用户配置优先级高于全局配置。两个文件使用相同的语法。<br>Fontconfig 配置文件使用 <a href="https://zh.wikipedia.org/wiki/XML" title="zhwp:XML">XML</a> 格式，其需要的头部如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;urn:fontconfig:fonts.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- settings go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="中文字体显示奇怪"><a href="#中文字体显示奇怪" class="headerlink" title="中文字体显示奇怪"></a>中文字体显示奇怪</h2><p>June 4, 2024</p><p>本次更新后中文不再是 Noto Sans 字体，变成了更细、发虚的字体（各种意义上太难看了</p><p>Arch论坛看了下：<br>由于近期 noto-fonts-cjk 打包变化，导致默认CJK回落字体不再是 Noto 系列字体。<a href="https://gitlab.archlinux.org/archlinux/packaging/packages/noto-fonts-cjk/-/issues/2">详情</a></p><p>解决方案：<br>在 ~&#x2F;.config&#x2F;fontconfig&#x2F; 下 新建一个字体文件（xxx.conf），让 <code>Noto Sans CJK SC</code> 优先使用即可：<br>参考：<a href="https://wiki.archlinuxcn.org/wiki/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E6%9C%AC%E5%9C%B0%E5%8C%96">修正简体中文显示为异体（日文）字形</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">fontconfig</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;fonts.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fontconfig</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>sans-serif<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">alias</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">family</span>&gt;</span>monospace<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prefer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK SC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK TC<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">family</span>&gt;</span>Noto Sans Mono CJK JP<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prefer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fontconfig</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Waydroid"><a href="#Waydroid" class="headerlink" title="Waydroid"></a>Waydroid</h1><p><del>没有waydroid，我怎么玩碧蓝航线啊（悲</del></p><h2 id="ERROR-Can’t-open-dev-binder-No-such-file-or-directory"><a href="#ERROR-Can’t-open-dev-binder-No-such-file-or-directory" class="headerlink" title="ERROR: Can’t open &#x2F;dev&#x2F;binder: No such file or directory"></a>ERROR: Can’t open &#x2F;dev&#x2F;binder: No such file or directory</h2><p>December 24, 2024</p><p>更新后发现 waydroid 挂了，表现为 <code>waydroid session start</code> 出错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[13:02:43] Failed to add presence handler: None  </span><br><span class="line">[gbinder] ERROR: Can&#x27;t open /dev/binder: No such file or directory</span><br></pre></td></tr></table></figure><p>看看 <code>binder_linux-dkms</code> 貌似也没啥问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pacman -Qi binder_linux-dkms-git</span></span><br><span class="line">名字           : binder_linux-dkms-git</span><br><span class="line">版本           : r57.ee4c25f-3</span><br><span class="line">描述           : Android kernel driver fork by @choff in DKMS format, binder only</span><br><span class="line">架构           : any</span><br><span class="line">URL            : https://github.com/choff/anbox-modules</span><br><span class="line">软件许可       : GPL-2.0-only</span><br><span class="line">组             : 无</span><br><span class="line">提供           : 无</span><br><span class="line">依赖于         : dkms</span><br><span class="line">可选依赖       : 无</span><br><span class="line">依赖它         : 无</span><br><span class="line">被可选依赖     : 无</span><br><span class="line">与它冲突       : binder_linux-dkms  anbox-modules-dkms</span><br><span class="line">取代           : binder_linux-dkms</span><br><span class="line">安装后大小     : 279.35 KiB</span><br><span class="line">打包者         : lilac-alarm (on behalf of i7arch) &lt;i7arch@member.fsf.org&gt;</span><br><span class="line">编译日期       : 2024年10月03日 星期四 19时16分59秒</span><br><span class="line">安装日期       : 2024年10月07日 星期一 19时46分44秒</span><br><span class="line">安装原因       : 单独指定安装</span><br><span class="line">安装脚本       : 否</span><br><span class="line">验证者         : SHA-256 校验值  数字签名</span><br></pre></td></tr></table></figure><p>去论坛看了下发现上周core&#x2F;linux已经启用了 binderfs 的MR合并，那可能是冲突了？然而卸载了<code>binder_linux-dkms-git</code>并没有成功启动。</p><p>最后根据waydroid文档的建议，尝试重置镜像之后就能正常使用了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> waydroid init -f</span></span><br></pre></td></tr></table></figure><h2 id="gbinder-Service-manager-dev-anbox-binder-has-appeared"><a href="#gbinder-Service-manager-dev-anbox-binder-has-appeared" class="headerlink" title="[gbinder] Service manager &#x2F;dev&#x2F;anbox-binder has appeared"></a><code>[gbinder]</code> Service manager &#x2F;dev&#x2F;anbox-binder has appeared</h2><p>January 18, 2025</p><p>今天重装了系统，发现Waydroid是挂的，一直在启动中挂起：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">waydroid session start</span></span><br><span class="line"></span><br><span class="line">[11:22:15] Starting waydroid session</span><br><span class="line">[gbinder] Service manager /dev/anbox-binder has appeared</span><br></pre></td></tr></table></figure><p>日志里只有lxc的地方看上去有点奇怪，但是我看不懂（</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">waydroid <span class="built_in">log</span></span></span><br><span class="line">(000837) [22:08:19] % mkdir -p /dev/binderfs</span><br><span class="line">(000837) [22:08:19] % mount -t binder binder /dev/binderfs</span><br><span class="line">(000837) [22:08:19] % ln -s /dev/binderfs/anbox-hwbinder /dev/binderfs/anbox-vndbinder /dev/binderfs/anbox-binder /dev/binderfs/features /dev/binderfs/binder-control /dev/</span><br><span class="line">(000837) [22:08:19] Save config: /var/lib/waydroid/waydroid.cfg</span><br><span class="line">(000837) [22:08:19] % modprobe -q ashmem_linux</span><br><span class="line">(000837) [22:08:19] % lxc-info --version</span><br><span class="line">6.0.3</span><br><span class="line">(000837) [22:08:19] % mkdir -p /var/lib/waydroid/lxc/waydroid</span><br><span class="line">(000837) [22:08:19] % sh -c cat &quot;/usr/lib/waydroid/data/configs/config_base&quot; &quot;/usr/lib/waydroid/data/configs/config_3&quot; &quot;/usr/lib/waydroid/data/configs/config_4&quot; &gt; &quot;/var/lib/waydroid/lxc/waydroid/config&quot;</span><br><span class="line">(000837) [22:08:19] % sed -i s/LXCARCH/x86_64/ /var/lib/waydroid/lxc/waydroid/config</span><br><span class="line">(000837) [22:08:19] % cp -fpr /usr/lib/waydroid/data/configs/waydroid.seccomp /var/lib/waydroid/lxc/waydroid/waydroid.seccomp</span><br><span class="line">(000837) [22:08:19] % systemctl is-active -q apparmor</span><br><span class="line">(000837) [22:08:19] % mv /var/lib/waydroid/config_nodes /var/lib/waydroid/lxc/waydroid</span><br><span class="line">(000592) [22:08:19] % lxc-info -P /var/lib/waydroid/lxc -n waydroid -sH</span><br><span class="line">STOPPED</span><br><span class="line">(000592) [22:08:19] % modprobe -q ashmem_linux</span><br><span class="line">(000592) [22:08:19] % chmod 666 -R /dev/anbox-binder</span><br><span class="line">(000592) [22:08:19] % chmod 666 -R /dev/anbox-vndbinder</span><br><span class="line">(000592) [22:08:19] % chmod 666 -R /dev/anbox-hwbinder</span><br><span class="line">(000592) [22:09:15] % /usr/lib/waydroid/data/scripts/waydroid-net.sh start</span><br><span class="line">vnic is waydroid0</span><br><span class="line">(000592) [22:09:15] % systemctl is-active -q nfcd</span><br><span class="line">(000592) [22:09:15] % chmod 777 -R /dev/dri</span><br><span class="line">(000592) [22:09:15] % chmod 777 -R /dev/fb0</span><br><span class="line">(000592) [22:09:15] % chmod 777 -R /dev/video0</span><br><span class="line">(000592) [22:09:15] % chmod 777 -R /dev/video1</span><br><span class="line">(000592) [22:09:15] % mv /var/lib/waydroid/config_session /var/lib/waydroid/lxc/waydroid</span><br><span class="line">(000592) [22:09:15] % mount -o ro /usr/share/waydroid-extra/images/system.img /var/lib/waydroid/rootfs</span><br><span class="line">(000592) [22:09:15] % mkdir -p /var/lib/waydroid/overlay_work/system</span><br><span class="line">(000592) [22:09:15] % mount -t overlay -o ro,lowerdir=/var/lib/waydroid/overlay:/var/lib/waydroid/rootfs,upperdir=/var/lib/waydroid/overlay_rw/system,workdir=/var/lib/waydroid/overlay_work/system,xino=off overlay /var/lib/waydroid/rootfs</span><br><span class="line">(000592) [22:09:15] % mount -o ro /usr/share/waydroid-extra/images/vendor.img /var/lib/waydroid/rootfs/vendor</span><br><span class="line">(000592) [22:09:15] % mkdir -p /var/lib/waydroid/overlay_work/vendor</span><br><span class="line">(000592) [22:09:15] % mount -t overlay -o ro,lowerdir=/var/lib/waydroid/overlay/vendor:/var/lib/waydroid/rootfs/vendor,upperdir=/var/lib/waydroid/overlay_rw/vendor,workdir=/var/lib/waydroid/overlay_work/vendor,xino=off overlay /var/lib/waydroid/rootfs/vendor</span><br><span class="line">(000592) [22:09:15] % mount -o bind /var/lib/waydroid/waydroid.prop /var/lib/waydroid/rootfs/vendor/waydroid.prop</span><br><span class="line">(000592) [22:09:15] Save config: /var/lib/waydroid/waydroid.cfg</span><br><span class="line">(000592) [22:09:15] % lxc-start -P /var/lib/waydroid/lxc -F -n waydroid -- /init</span><br><span class="line">(000592) [22:09:15] New background process: pid=1129, output=background</span><br><span class="line">(000592) [22:09:15] % lxc-info -P /var/lib/waydroid/lxc -n waydroid -sH</span><br><span class="line">RUNNING</span><br><span class="line">(001076) [22:09:15] Skipping clipboard manager service because of missing pyclip package</span><br><span class="line">(001577) [22:09:41] % tail -n 60 -F /var/lib/waydroid/waydroid.log</span><br><span class="line">(001577) [22:09:41] *** output passed to waydroid stdout, not to this log ***</span><br></pre></td></tr></table></figure><p>排查了很久，根本找不到问题所在。直到我尝试用软解成功启动waydroid。那肯定是显卡的问题。有点纳闷我寻思也是混合模式啊，不应该是优先核显嘛…<br>而且检查结果也没问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">glxinfo | grep <span class="string">&#x27;OpenGL renderer&#x27;</span></span></span><br><span class="line">OpenGL renderer string: AMD Radeon 680M (radeonsi, rembrandt, LLVM 19.1.6, DRM 3.59, 6.12.9-arch1-1)</span><br></pre></td></tr></table></figure><p>看着waydroid的默认配置，我还是觉得和显卡有关，但是死活找不出原因（</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/waydroid/waydroid_base.prop</span><br><span class="line">------------------------------------</span><br><span class="line">sys.use_memfd=true</span><br><span class="line">debug.stagefright.ccodec=0</span><br><span class="line">ro.hardware.gralloc=gbm</span><br><span class="line">ro.hardware.egl=mesa</span><br><span class="line">ro.hardware.vulkan=radeon</span><br><span class="line">ro.hardware.camera=v4l2</span><br><span class="line">ro.opengles.version=196609</span><br><span class="line">waydroid.system_ota=https://ota.waydro.id/system/lineage/waydroid_x86_64/VANILLA.json</span><br><span class="line">waydroid.vendor_ota=https://ota.waydro.id/vendor/waydroid_x86_64/MAINLINE.json</span><br><span class="line">waydroid.tools_version=1.4.3</span><br><span class="line">ro.vndk.lite=true</span><br></pre></td></tr></table></figure><p>直到我看到了一个issues：<br><a href="https://github.com/waydroid/waydroid/issues/1487">[gbinder] Service manager &#x2F;dev&#x2F;anbox-binder has appeared <em>than hangs</em></a></p><p>eglinfo看了下，已经确定是同一个问题，内核早加载的时候，优先使用了Nvidia</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">eglinfo -B</span></span><br><span class="line">GBM platform:</span><br><span class="line">EGL API version: 1.5</span><br><span class="line">EGL vendor string: NVIDIA</span><br><span class="line">EGL version string: 1.5</span><br><span class="line">EGL client APIs: OpenGL_ES OpenGL</span><br><span class="line">OpenGL core profile vendor: NVIDIA Corporation</span><br><span class="line">OpenGL core profile renderer: NVIDIA GeForce RTX 3060 Laptop GPU/PCIe/SSE2</span><br><span class="line">OpenGL core profile version: 4.6.0 NVIDIA 565.77</span><br><span class="line">OpenGL core profile shading language version: 4.60 NVIDIA</span><br><span class="line">OpenGL compatibility profile vendor: NVIDIA Corporation</span><br><span class="line">OpenGL compatibility profile renderer: NVIDIA GeForce RTX 3060 Laptop GPU/PCIe/SSE2</span><br><span class="line">OpenGL compatibility profile version: 4.6.0 NVIDIA 565.77</span><br><span class="line">OpenGL compatibility profile shading language version: 4.60 NVIDIA</span><br><span class="line">OpenGL ES profile vendor: NVIDIA Corporation</span><br><span class="line">OpenGL ES profile renderer: NVIDIA GeForce RTX 3060 Laptop GPU/PCIe/SSE2</span><br><span class="line">OpenGL ES profile version: OpenGL ES 3.2 NVIDIA 565.77</span><br><span class="line">OpenGL ES profile shading language version: OpenGL ES GLSL ES 3.20</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决办法是，在 <code>/etc/mkinitcpio.conf</code> 的HOOK数组上添加回来 <code>kms</code> ，并重做 <code>mkinitcpio</code> ，重启之后，gbm就会优先让AMD工作。最后再重置waydroid镜像就正常工作了</p><p><a href="https://wiki.archlinuxcn.org/wiki/NVIDIA#">在HOOK数组删 <code>kms</code> 模块的原因</a><br>但是当我加上 <code>kms</code> 后，也没在 journalctl -b 找到 <code>nouveau</code> 的东西，估计没啥大问题。</p><h2 id="镜像Bug"><a href="#镜像Bug" class="headerlink" title="镜像Bug"></a>镜像Bug</h2><p>May 20, 2025</p><p>今天久违更新了镜像，发现 <code>adb shell wm size 1280x720</code> 后鼠标触摸出错，只能点击部分区域（1280x720大小），应该是把Los20版本的一些东西搞到Los18版本出现的不兼容。</p><p>解决方法是回到推出Los20测试镜像前的Los18镜像，即版本时间线为2025-04-13的system和vendor。</p><p>关于如何自定义镜像版本：<br><a href="https://docs.waydro.id/faq/using-custom-waydroid-images">https://docs.waydro.id/faq/using-custom-waydroid-images</a></p><h1 id="屏幕刷新率"><a href="#屏幕刷新率" class="headerlink" title="屏幕刷新率"></a>屏幕刷新率</h1><p>February 04, 2025</p><p>今天更新后发现核显的刷新率只能以60HZ显示了（习惯了240HZ看60HZ真难受）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wlr-randr</span></span><br><span class="line">eDP-1 &quot;Thermotrex Corporation TL160ADMP11-0 (eDP-1)&quot;</span><br><span class="line">  Make: Thermotrex Corporation</span><br><span class="line">  Model: TL160ADMP11-0</span><br><span class="line">  Serial: (null)</span><br><span class="line">  Physical size: 350x220 mm</span><br><span class="line">  Enabled: yes</span><br><span class="line">  Modes:</span><br><span class="line">    2560x1600 px, 60.000000 Hz (preferred, current)</span><br><span class="line">    1920x1200 px, 60.000000 Hz</span><br><span class="line">    1920x1080 px, 60.000000 Hz</span><br><span class="line">    1600x1200 px, 60.000000 Hz</span><br><span class="line">    1680x1050 px, 60.000000 Hz</span><br><span class="line">    1280x1024 px, 60.000000 Hz</span><br><span class="line">    1440x900 px, 60.000000 Hz</span><br><span class="line">    1280x800 px, 60.000000 Hz</span><br><span class="line">    1280x720 px, 60.000000 Hz</span><br><span class="line">    1024x768 px, 60.000000 Hz</span><br><span class="line">    800x600 px, 60.000000 Hz</span><br><span class="line">    640x480 px, 60.000000 Hz</span><br><span class="line">  Position: 0,0</span><br><span class="line">  Transform: normal</span><br><span class="line">  Scale: 1.500000</span><br><span class="line">  Adaptive Sync: disabled</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Linux ATRI 6.13.1-arch1-1 #1 SMP PREEMPT_DYNAMIC Sun, 02 Feb 2025 01:02:29 +0000 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>切换了一下内核发现又能核显240HZ了，估计是内核的bug。不太懂，摆了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wlr-randr</span></span><br><span class="line">eDP-1 &quot;Thermotrex Corporation TL160ADMP11-0 (eDP-1)&quot;</span><br><span class="line">  Make: Thermotrex Corporation</span><br><span class="line">  Model: TL160ADMP11-0</span><br><span class="line">  Serial: (null)</span><br><span class="line">  Physical size: 350x220 mm</span><br><span class="line">  Enabled: yes</span><br><span class="line">  Modes:</span><br><span class="line">    2560x1600 px, 239.998001 Hz (preferred, current)</span><br><span class="line">    2560x1600 px, 59.999001 Hz (preferred)</span><br><span class="line">    1920x1200 px, 239.998001 Hz</span><br><span class="line">    1920x1080 px, 239.998001 Hz</span><br><span class="line">    1600x1200 px, 239.998001 Hz</span><br><span class="line">    1680x1050 px, 239.998001 Hz</span><br><span class="line">    1280x1024 px, 239.998001 Hz</span><br><span class="line">    1440x900 px, 239.998001 Hz</span><br><span class="line">    1280x800 px, 239.998001 Hz</span><br><span class="line">    1280x720 px, 239.998001 Hz</span><br><span class="line">    1024x768 px, 239.998001 Hz</span><br><span class="line">    800x600 px, 239.998001 Hz</span><br><span class="line">    640x480 px, 239.998001 Hz</span><br><span class="line">  Position: 0,0</span><br><span class="line">  Transform: normal</span><br><span class="line">  Scale: 1.500000</span><br><span class="line">  Adaptive Sync: disabled</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -a</span></span><br><span class="line">Linux ATRI 6.12.12-1-lts #1 SMP PREEMPT_DYNAMIC Sat, 01 Feb 2025 18:47:29 +0000 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>August 20, 2025<br>七月的某次更新修复了这个问题，具体内容有点忘记了，做个结果补记一下</p><h1 id="home挂载失败"><a href="#home挂载失败" class="headerlink" title="&#x2F;home挂载失败"></a>&#x2F;home挂载失败</h1><p>开机显示<br><img src="/1ab51985d1ca/20251021105415.png"><br>貌似是硬盘的问题，但是其他分区能挂载，应该不是整个盘炸了</p><p>由开机时的报错提示看应该是 <code>/home</code> 出了问题</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[FAILED] Failed to start File System Check on /dev/disk/by-uuid/0d34532b-4120-4ad6-8153-e208696ac4f1. See &#x27;systemctl status &quot;systemd-fsck@dev-disk-by\\x2duuid-0d34532b\\x2d4120\\x2d4ad6\\x2d8153\\x2de208696ac4f1.service&quot;&#x27; for details. [DEPEND] Dependency failed for /home. [DEPEND] Dependency failed for Local File Systems. [ OK ] Started D-Bus User Bus.</span><br></pre></td></tr></table></figure><p>挂载失败？使用 <code>blkid</code> 对比了<code>/etc/fstab</code>上的UUID好像也没问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lsblk</span></span><br><span class="line">NAME          MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">nvme0n1       259:5    0   1.9T  0 disk /mnt/data</span><br><span class="line">nvme1n1       259:0    0 931.5G  0 disk</span><br><span class="line">├─nvme1n1p1   259:1    0     1G  0 part /boot</span><br><span class="line">├─nvme1n1p2   259:2    0    32G  0 part [SWAP]</span><br><span class="line">├─nvme1n1p3   259:3    0   128G  0 part /</span><br><span class="line">└─nvme1n1p4   259:4    0 770.5G  0 part</span><br></pre></td></tr></table></figure><p>使用 <code>mount -a</code> 查看显示分区出现错误，奇怪的是再次使用 <code>lsblk</code> 查看又能挂载了（重试了几次发现是 <code>mount -a</code> 命令导致的，并且使用 <code>mount -a</code> 一次之后再次使用将不显示分区出现错误，检测不出错误了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount -a</span></span><br><span class="line">[  34.606814] EXT4-fs (nvme1n1p4): warning: mounting fs with errors, running e2fsck is recommended</span><br><span class="line"></span><br><span class="line"><span class="comment"># lsblk</span></span><br><span class="line">NAME          MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">nvme1n1       259:0    0 931.5G  0 disk</span><br><span class="line">├─nvme1n1p1   259:1    0     1G  0 part /boot</span><br><span class="line">├─nvme1n1p2   259:2    0    32G  0 part [SWAP]</span><br><span class="line">├─nvme1n1p3   259:3    0   128G  0 part /</span><br><span class="line">└─nvme1n1p4   259:4    0 770.5G  0 part /home</span><br><span class="line">nvme0n1       259:5    0   1.9T  0 disk /mnt/data</span><br></pre></td></tr></table></figure><p>按提示使用e2fsck（Linux 系统中用于检查和修复 ext2、ext3、ext4 文件系统的命令行工具）</p><p>由于薛定谔的挂载，还是手动卸载挂载 <code>/home</code> 先</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># umount /dev/nvme0n1p4</span></span><br></pre></td></tr></table></figure><p>然后使用工具修复</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># e2fsck -y /dev/nvme0n1p4</span></span><br><span class="line">......</span><br><span class="line">/dev/nvme0n1p4: ***** FILE SYSTEM WAS MODIFIED ***** </span><br><span class="line">/dev/nvme0n1p4: 309933/50503680 files (1.3% non-contiguous), 17569752/201985024 blocks </span><br></pre></td></tr></table></figure><p>重启完事</p><p>原因猜测：<br>这几天我没有进行系统更新啥的，也没有修改系统设置。<br>唯一让我觉得有关联的事情就是，前段时间宿舍频繁停电，可能埋下了问题。<br>也有可能是其他原因。</p>]]></content>
      
      
      <categories>
          
          <category> GNU/Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Archlinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch日常维护手册</title>
      <link href="/0b5e5b638425/"/>
      <url>/0b5e5b638425/</url>
      
        <content type="html"><![CDATA[<h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><h2 id="pacman"><a href="#pacman" class="headerlink" title="pacman"></a>pacman</h2><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>升级系统及所有已经安装的软件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syu</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>直接安装某一个包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S &lt;packageName&gt;</span><br></pre></td></tr></table></figure><h3 id="安装原因"><a href="#安装原因" class="headerlink" title="安装原因"></a>安装原因</h3><p>pacman 数据库将软件包按照安装的原因分为两类：</p><ul><li><strong>显式安装</strong>：那些真正地被传递给通用 pacman <code>-S</code>和<code>-U</code>命令的包；</li><li><strong>依赖</strong>：那些虽然（一般）从未被传递给 pacman 安装命令，但由于被其它显式安装的包<a href="https://wiki.archlinuxcn.org/wzh/index.php?title=Dependency&action=edit&redlink=1" title="Dependency（页面不存在）">需要</a>从而被隐式安装的包</li></ul><p>当安装软件包时，可以把安装原因强制设为<strong>依赖</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S --asdeps &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>该命令使用的原因通常是显式安装的包可能会提供<a href="https://wiki.archlinuxcn.org/wiki/PKGBUILD#optdepends" title="PKGBUILD">可选安装包</a>，这些包提供了非必须功能，可供用户自由选择。</p><blockquote><p>提示：用<code>--asdeps</code>安装可选依赖将确保如果你<a href="https://wiki.archlinuxcn.org/wiki/Pacman/%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7#%E5%88%A0%E9%99%A4%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85%EF%BC%88%E5%AD%A4%E7%AB%8B%E8%BD%AF%E4%BB%B6%E5%8C%85%EF%BC%89" title="Pacman&#x2F;提示和技巧">移除孤立包</a>，pacman 将会一同移除按照上述方法指定安装的可选依赖。</p></blockquote><p>但是重新安装该软件包，当前安装原因默认会被保留。</p><p>显式安装的软件包列表可用<code>pacman -Qe</code>获取, 设置为依赖的软件包可用<code>pacman -Qd</code>获取。</p><p>改变某个已安装软件包的安装原因，可以执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -D --asdeps &lt;package_name&gt;</span><br></pre></td></tr></table></figure><p>反过来的对应参数<code>--asexplicit</code></p><p><strong>注意：</strong> 在升级时使用<code>--asdeps</code>和<code>--asexplicit</code>选项，例如<code>pacman -Syu &lt;package_name&gt; --asdeps</code>，是不被推荐的。这会导致不仅改变要被安装的软件包的安装原因，也会改变被升级的软件包的安装原因。</p><blockquote><p>根据2021.05-1之后的行为变化，即使指定了 <code>--asdeps</code> 参数，<code>&lt;package_name&gt;</code> 本身仍然会被视为显式安装的包。只能显示安装后在通过 <code>pacman -D --asdeps &lt;package_name&gt;</code> 变为以依赖安装</p></blockquote><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pacman -Ss &lt;packageName&gt; <span class="comment"># 在仓库中搜索含关键字的软件包（本地已安装的会标记）</span></span><br><span class="line"></span><br><span class="line">pacman -Qs &lt;packageName&gt; <span class="comment"># 搜索已安装的软件包</span></span><br><span class="line"></span><br><span class="line">pacman -Qu <span class="comment"># 列出所有可升级的软件包</span></span><br><span class="line"></span><br><span class="line">pacman -Qt <span class="comment"># 列出不被任何软件要求的软件包</span></span><br><span class="line"></span><br><span class="line">pacman -Q &lt;packageName&gt; <span class="comment"># 查看软件包是否已安装，已安装则显示软件包名称和版本</span></span><br><span class="line"></span><br><span class="line">pacman -Qi &lt;packageName&gt; <span class="comment"># 查看某个软件包信息，显示较为详细的信息，包括描述、构架、依赖、大小等等</span></span><br><span class="line"></span><br><span class="line">pacman -Ql &lt;packageName&gt; <span class="comment"># 列出软件包内所有文件，包括软件安装的每个文件、文件夹的名称和路径</span></span><br><span class="line"></span><br><span class="line">pacman -Qo /path/to/a/file <span class="comment"># 可以通过查询数据库获知目前你的文件系统中某个文件是属于哪个软件包</span></span><br><span class="line"></span><br><span class="line">pacman -Qdt <span class="comment"># 罗列所有不再作为依赖的软件包（孤立 orphans)</span></span><br></pre></td></tr></table></figure><h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><p>删除孤立软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Rns $(pacman -Qtdq)</span><br></pre></td></tr></table></figure><p>删除当前未安装的所有缓存包和未使用的同步数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Sc</span><br></pre></td></tr></table></figure><p>从缓存中删除所有文件，这是最激进的方法，不会在缓存文件夹中留下任何内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Scc</span><br></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pacman -Rns &lt;packageName&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -R 删除单个软件包，会保留其全部已经安装的依赖关系</span></span><br><span class="line"><span class="comment"># -n pacman 删除某些程序时会备份重要配置文件，在其后面加上*.pacsave扩展名。-n 选项可以避免备份这些文件</span></span><br><span class="line"><span class="comment"># -s 删除其所有没有被其他已安装软件包使用的依赖关系</span></span><br></pre></td></tr></table></figure><h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><p>在不同的 <code>-大写字母</code>，可跟着不同的小写字母实现更多不同的功能，具体可用指南查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -h <span class="comment"># 查看指南</span></span><br><span class="line"></span><br><span class="line">pacman &#123;-R --remove&#125; <span class="comment"># 查看 -R 的可选参数</span></span><br></pre></td></tr></table></figure><h2 id="yay"><a href="#yay" class="headerlink" title="yay"></a>yay</h2><h3 id="升级-1"><a href="#升级-1" class="headerlink" title="升级"></a>升级</h3><p>升级系统，相当于yay -Syu</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay</span><br></pre></td></tr></table></figure><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S &lt;packageName&gt;</span><br></pre></td></tr></table></figure><h3 id="搜索-1"><a href="#搜索-1" class="headerlink" title="搜索"></a>搜索</h3><p>查看仅通过yay安装的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Qm</span><br></pre></td></tr></table></figure><h3 id="卸载-1"><a href="#卸载-1" class="headerlink" title="卸载"></a>卸载</h3><p>要删除包及其依赖项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Rns &lt;packageName&gt;</span><br></pre></td></tr></table></figure><h3 id="清理-1"><a href="#清理-1" class="headerlink" title="清理"></a>清理</h3><p>清理 yay 缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf ~/.cache/yay</span><br></pre></td></tr></table></figure><p>清理孤立的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yay -Yc</span><br><span class="line"></span><br><span class="line"><span class="comment"># -Y：表示同时清理未使用的依赖项。</span></span><br><span class="line"><span class="comment"># -c：表示清理缓存，即删除已下载的软件包文件。</span></span><br></pre></td></tr></table></figure><h3 id="其他用法-1"><a href="#其他用法-1" class="headerlink" title="其他用法"></a>其他用法</h3><p>打印系统统计信息，显示已安装软件包和系统健康状况的统计数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -Ps</span><br></pre></td></tr></table></figure><h2 id="pacnew处理"><a href="#pacnew处理" class="headerlink" title="pacnew处理"></a>pacnew处理</h2><p>处理过程基本一致，请看<code>mkinitcpio.conf变动</code>章节</p><h2 id="mkinitcpio-conf变动"><a href="#mkinitcpio-conf变动" class="headerlink" title="mkinitcpio.conf变动"></a>mkinitcpio.conf变动</h2><p>在Arch Linux系统中，<code>mkinitcpio.conf</code> 是一个非常重要的配置文件，它用于定义在初始化ramdisk（initrd或initramfs）创建过程中包含哪些模块和文件。<br>这个配置对系统启动至关重要。当系统更新并且这个更新影响到 <code>mkinitcpio</code> 时，可能会生成一个新的配置文件示例，名为 <code>mkinitcpio.conf.pacnew</code> 。</p><p>处理 <code>mkinitcpio.conf</code> 和 <code>mkinitcpio.conf.pacnew</code> 文件步骤如下：</p><ol><li>首先，你需要检查 <code>.pacnew</code> 文件与现有的 <code>mkinitcpio.conf</code> 文件之间的差异。可以使用 <code>nvim -d</code> （Diff mode）来完成这一任务。如：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvim -d /etc/mkinitcpio.conf /etc/mkinitcpio.conf.pacnew</span><br><span class="line"><span class="comment"># 这将显示两个文件之间的差异。vimdiff 的使用看 vim 篇</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在做任何更改之前，建议备份原始的 <code>mkinitcpio.conf</code> 文件。这样，如果新的配置导致问题，你可以轻松地回滚到之前的配置。如：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /etc/mkinitcpio.conf /etc/mkinitcpio.conf.bak</span><br></pre></td></tr></table></figure><ol start="3"><li><p>把 <code>mkinitcpio.conf.pavnew</code> 的新增参数内容复制到 <code>mkinitcpio.conf</code> ，对于不同的参数的值，请谨慎更改或保留。（建议使用 vim&#x2F;neovim 的 <a href="https://neovim.io/doc/user/diff.html#_1.-starting-diff-mode">diff 模式</a> 完成）</p></li><li><p>一旦你合并了并保存了 <code>mkinitcpio.conf</code> 文件，你需要重新生成 initramfs 使更改生效：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkinitcpio -P</span><br><span class="line"><span class="comment"># 为所有已安装的内核生成新的initramfs。</span></span><br></pre></td></tr></table></figure><ol start="5"><li>更改生效后，重启你的系统以确保一切正常工作。没啥问题就可以删除<code>.pacnew</code>文件和备份文件了</li></ol><h3 id="mkinitcpio-P"><a href="#mkinitcpio-P" class="headerlink" title="mkinitcpio -P"></a>mkinitcpio -P</h3><p>命令<code>mkinitcpio -P</code>在Arch Linux及其衍生系统中用于重新生成所有已安装内核的初始RAM磁盘（initramfs）。initramfs是一个临时的根文件系统，加载到内存中，在Linux系统启动过程中被用来准备真正的根文件系统。</p><p>具体来说，<code>mkinitcpio -P</code>命令的作用包括：</p><ul><li><p><strong>自动检测</strong>：该命令会自动检测<code>/boot</code>目录下所有已安装的Linux内核，并为每个内核生成对应的initramfs。这意味着如果你有多个内核版本（例如，标准Linux内核和LTS版本内核），该命令将为它们每一个重新生成initramfs。</p></li><li><p><strong>应用配置更改</strong>：如果你更改了<code>/etc/mkinitcpio.conf</code>配置文件或者相关的钩子脚本（hooks），使用<code>mkinitcpio -P</code>可以确保这些更改被应用到所有内核的initramfs中。这对于添加驱动、修改启动行为等操作至关重要。</p></li><li><p><strong>修复启动问题</strong>：在某些情况下，如果系统无法启动，可能是因为initramfs损坏或配置不正确。在这种情况下，重新生成initramfs可能有助于解决问题。</p></li><li><p><strong>更新内核后的必要步骤</strong>：当通过包管理器更新Linux内核后，通常会自动重新生成initramfs。然而，在手动安装或更新内核、更改重要的启动配置时，运行<code>mkinitcpio -P</code>确保initramfs是最新的并且包含所有必要的模块和配置。</p></li></ul><h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><h2 id="df命令（Disk-Free）"><a href="#df命令（Disk-Free）" class="headerlink" title="df命令（Disk Free）"></a>df命令（Disk Free）</h2><p>显示 <strong>文件系统级别（挂载的磁盘&#x2F;分区）</strong> 的整体磁盘空间使用情况，包括总容量、已用空间、剩余空间等。-h 后的默认参数为 <code>/</code> ，即根目录，查看的是根目录中所有分区的空间使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h <span class="comment"># 以人类可读格式显示</span></span><br></pre></td></tr></table></figure><p>若想查看指定一目录的分区的空间使用情况，可以在 -h 后自定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h /mnt <span class="comment"># 查看/mnt目录下空间使用情况</span></span><br></pre></td></tr></table></figure><h2 id="du命令（Disk-Usage）"><a href="#du命令（Disk-Usage）" class="headerlink" title="du命令（Disk Usage）"></a>du命令（Disk Usage）</h2><p>计算 <strong>文件或目录</strong> 的实际磁盘使用量（递归统计文件和子目录占用的空间）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh /path/to/dir   <span class="comment"># 统计目录总大小（-s 汇总，-h 易读格式）</span></span><br><span class="line"><span class="built_in">du</span> -ah /path/to/dir   <span class="comment"># 显示目录下所有文件和子目录的详细大小</span></span><br></pre></td></tr></table></figure><h2 id="Smartmontools"><a href="#Smartmontools" class="headerlink" title="Smartmontools"></a>Smartmontools</h2><ol><li>安装 smartmontools</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S smartmontools</span><br></pre></td></tr></table></figure><ol start="2"><li>使用以下命令获取磁盘设备名称或路径</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 <code>smartctl</code> 命令来查看磁盘信息：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">smartctl -A /dev/sdx <span class="comment"># 硬盘</span></span><br><span class="line">smartctl -d sat -A /dev/sdx <span class="comment"># USB 设备</span></span><br></pre></td></tr></table></figure><p>   这两个命令的主要区别是添加了 <code>-d</code> 选项，该选项指定驱动程序，以便 <code>smartctl</code> 可以与相应的设备进行通信。<br>   如果需要更加详细的信息，请把 <code>-A</code> 改为 <code>-a</code> 。</p><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><ol><li>查看trim定时器状态</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status fstrim.timer  </span><br></pre></td></tr></table></figure><ol start="2"><li>手动 trim</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fstrim -a -v</span><br></pre></td></tr></table></figure><ul><li><code>-a</code> 或 <code>--all</code>：这个选项指示<code>fstrim</code>命令尝试对所有挂载的文件系统进行trim操作，但它会跳过那些不支持trim的文件系统。</li><li><code>-v</code> 或 <code>--verbose</code>：这个选项让<code>fstrim</code>命令在执行时显示更多信息，特别是关于它对每个文件系统进行了多少trim操作的详细信息。</li></ul><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="日志清理"><a href="#日志清理" class="headerlink" title="日志清理"></a>日志清理</h2><p>清理最早两周前的日志.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --vacuum-time=2s</span><br></pre></td></tr></table></figure><p>清理日志使总大小小于 100M:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --vacuum-size=100M</span><br></pre></td></tr></table></figure><h2 id="pacman日志"><a href="#pacman日志" class="headerlink" title="pacman日志"></a>pacman日志</h2><p>一般只会保留数天的记录，使用 cat 抓取就行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/pacman.log </span><br></pre></td></tr></table></figure><h2 id="读取日志"><a href="#读取日志" class="headerlink" title="读取日志"></a>读取日志</h2><p>检查上一次引导（boot）时的系统日志的命令（包括内核和用户空间日志）。依赖 <code>systemd-journald</code> 的持久化存储。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># `-b` 表示启动周期（`boot`），`-1` 表示上一次启动（`-0` 是当前启动，默认值）。</span></span><br></pre></td></tr></table></figure><hr><p>直接读取 <strong>内核环形缓冲区</strong>（<code>kernel ring buffer</code>）的内容，记录内核启动过程中和运行时的日志（如硬件检测、驱动加载、内核错误等）。<br>这些日志是内核直接生成的，<strong>不依赖任何日志系统</strong>（如 <code>systemd-journald</code>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dmesg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认显示当前启动周期的内核日志（重启后会丢失之前的日志）。  </span></span><br><span class="line"><span class="comment"># 可通过 `-T` 或 `--time-format` 选项显示时间戳（需内核支持）。</span></span><br></pre></td></tr></table></figure><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="1-使用ps命令"><a href="#1-使用ps命令" class="headerlink" title="1. 使用ps命令"></a>1. 使用ps命令</h2><p><code>ps</code>命令是一个非常通用的命令，它在几乎所有的Linux发行版中都可用，包括Arch Linux。</p><p>查看当前系统中的所有进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><p>  这里，<code>-e</code>表示显示所有进程，<code>-f</code>表示全格式显示。</p><p>查看与某个用户相关的进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -u &lt;用户名&gt;</span><br></pre></td></tr></table></figure><p>查看某个特定进程的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -p &lt;进程ID&gt;</span><br></pre></td></tr></table></figure><h2 id="2-使用top命令"><a href="#2-使用top命令" class="headerlink" title="2. 使用top命令"></a>2. 使用top命令</h2><p><code>top</code>命令提供了一个实时更新的进程列表，显示系统中进程的动态视图。</p><p>启动<code>top</code>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><code>top</code>命令会显示一系列的进程信息，包括CPU使用率、内存使用率等。可以在<code>top</code>运行时按键来改变其行为:</p><ol><li>如按<code>P</code>排序显示CPU使用率最高的进程。</li><li>按 <code>q</code> 退出。</li></ol><blockquote><p>可以使用拥有更好交互图形界面的 htop。</p></blockquote><h1 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h1><p>开启蓝牙服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start bluetooth</span><br></pre></td></tr></table></figure><h1 id="WIFI-NetworkManager"><a href="#WIFI-NetworkManager" class="headerlink" title="WIFI-NetworkManager"></a>WIFI-NetworkManager</h1><h2 id="nmcli-examples"><a href="#nmcli-examples" class="headerlink" title="nmcli examples"></a>nmcli examples</h2><p><a href="https://wiki.archlinuxcn.org/wiki/NetworkManager">https://wiki.archlinuxcn.org/wiki/NetworkManager</a></p><p>List nearby Wi-Fi networks:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi list</span><br></pre></td></tr></table></figure><p>Connect to a Wi-Fi network:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi connect _SSID_or_BSSID_ password _password_</span><br></pre></td></tr></table></figure><p>Connect to a hidden Wi-Fi network:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi connect _SSID_or_BSSID_ password _password_ hidden <span class="built_in">yes</span></span><br></pre></td></tr></table></figure><p>Get a list of connections with their names, UUIDs, types and backing devices:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show</span><br></pre></td></tr></table></figure><p>Delete a connection:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection delete _name_or_uuid_</span><br></pre></td></tr></table></figure><p>See a list of network devices and their state:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device</span><br></pre></td></tr></table></figure><p>Turn off Wi-Fi:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli radio wifi off</span><br></pre></td></tr></table></figure><h1 id="临时粘贴版-fars-ee"><a href="#临时粘贴版-fars-ee" class="headerlink" title="临时粘贴版 fars.ee"></a>临时粘贴版 fars.ee</h1><p>官网： <a href="http://fars.ee/">http://fars.ee/</a></p><p><del>用于把日志、配置贴到任何人都能访问的网络上，用于让大佬给你分析问题</del></p><blockquote><p>注意隐私</p></blockquote><p>以下为基本使用，更多用法看官网<br>Create a paste from the output of ‘dmesg’:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ dmesg | curl -F <span class="string">&quot;c=@-&quot;</span> <span class="string">&quot;http://fars.ee/&quot;</span></span><br><span class="line"></span><br><span class="line">:<span class="string">&#x27; output</span></span><br><span class="line"><span class="string">long: AGhkV6JANmmQRVssSUzFWa_0VNyq</span></span><br><span class="line"><span class="string">sha1: 686457a240366990455b2c494cc559aff454dcaa</span></span><br><span class="line"><span class="string">short: VNyq</span></span><br><span class="line"><span class="string">url: http://fars.ee/VNyq</span></span><br><span class="line"><span class="string">uuid: 17c5829d-81a0-4eb6-8681-ba72f83ffbf3</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h1><p>首先确保已经安装了 <code>mesa-utils</code> 、<code>lib32-nvidia-utils</code>、<code>nvidia-utils</code>、<code>nvidia</code> 和 <code>nvidia-utils</code>等相关驱动（或者AMD的相关包）</p><h2 id="查看当前的显卡渲染器"><a href="#查看当前的显卡渲染器" class="headerlink" title="查看当前的显卡渲染器"></a>查看当前的显卡渲染器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glxinfo | grep <span class="string">&quot;OpenGL renderer&quot;</span></span><br></pre></td></tr></table></figure><h2 id="监控-Nvidia-GPU"><a href="#监控-Nvidia-GPU" class="headerlink" title="监控 Nvidia GPU"></a>监控 Nvidia GPU</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure><h1 id="Archiving-and-compression"><a href="#Archiving-and-compression" class="headerlink" title="Archiving and compression"></a>Archiving and compression</h1><h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h2><ul><li>LZMA2(xz)：高压缩率的代表，但是压缩&#x2F;解压占用更多的cpu等资源</li><li>Zstd：是LZMA2和LZ4的平衡，压缩率与速度的性价比很高</li><li>LZ4：极速压缩&#x2F;解压的代表，占用资源低，但是压缩率比较低</li></ul><p>根据数据的冷热自行选择</p><h2 id="bsdtar"><a href="#bsdtar" class="headerlink" title="bsdtar"></a>bsdtar</h2><blockquote><p>提示：GNU 和 BSD tar 都自动为 bzip2、compress、gzip、lzip、lzma、lzop、zstd 和 xz 压缩归档执行解压缩。lz4 只有 BSD tar 支持（但是 GNU tar 可以使用–use-compress-program&#x3D;lz4&#x2F;-Ilz4进行等效操作）。当创建归档文件时，两者都支持-a开关，以根据文件扩展名通过正确的压缩程序自动处理创建的归档。BSD tar 根据格式识别压缩格式，而 GNU tar 只根据文件扩展名猜测压缩格式。</p></blockquote><p><a href="https://man.archlinux.org/man/bsdtar.1">bsdtar-man手册</a></p><p>常规用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">First option must be a mode specifier:</span><br><span class="line">  -c Create  -r Add/Replace  -t List  -u Update  -x Extract</span><br><span class="line">Common Options:</span><br><span class="line">  -b <span class="comment">#  Use # 512-byte records per I/O block</span></span><br><span class="line">  -f &lt;filename&gt;  Location of archive (default /dev/st0)</span><br><span class="line">  -v    Verbose</span><br><span class="line">  -w    Interactive</span><br><span class="line">Create: bsdtar -c [options] [&lt;file&gt; | &lt;<span class="built_in">dir</span>&gt; | @&lt;archive&gt; | -C &lt;<span class="built_in">dir</span>&gt; ]</span><br><span class="line">  &lt;file&gt;, &lt;<span class="built_in">dir</span>&gt;  add these items to archive</span><br><span class="line">  -z, -j, -J, --lzma  Compress archive with gzip/bzip2/xz/lzma</span><br><span class="line">  --format &#123;ustar|pax|cpio|shar&#125;  Select archive format</span><br><span class="line">  --exclude &lt;pattern&gt;  Skip files that match pattern</span><br><span class="line">  -C &lt;<span class="built_in">dir</span>&gt;  Change to &lt;<span class="built_in">dir</span>&gt; before processing remaining files</span><br><span class="line">  @&lt;archive&gt;  Add entries from &lt;archive&gt; to output</span><br><span class="line">List: bsdtar -t [options] [&lt;patterns&gt;]</span><br><span class="line">  &lt;patterns&gt;  If specified, list only entries that match</span><br><span class="line">Extract: bsdtar -x [options] [&lt;patterns&gt;]</span><br><span class="line">  &lt;patterns&gt;  If specified, extract only entries that match</span><br><span class="line">  -k    Keep (don<span class="string">&#x27;t overwrite) existing files</span></span><br><span class="line"><span class="string">  -m    Don&#x27;</span>t restore modification <span class="built_in">times</span></span><br><span class="line">  -O    Write entries to stdout, don<span class="string">&#x27;t restore to disk</span></span><br><span class="line"><span class="string">  -p    Restore permissions (including ACLs, owner, file flags)</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bsdtar -cJf &lt;archive_name.tar.xz&gt; [--options xz:compression-level=9] &lt;/path/to/directory&gt;</span><br></pre></td></tr></table></figure><p>针对 .tar.xz 文件完整性检查</p><ul><li>bsdtar 的 -t 选项可以列出压缩包内的文件列表，确保元数据正常。如果压缩包损坏，此操作会直接报错。</li><li>通过对比归档的哈希值，确保整个归档未被篡改<br>e.g.</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bsdtar -tvf &lt;filename&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sha256sum</span> &lt;filename&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GNU/Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Archlinux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
